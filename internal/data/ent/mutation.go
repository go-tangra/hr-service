// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/go-tangra/go-tangra-hr/internal/data/ent/absencetype"
	"github.com/go-tangra/go-tangra-hr/internal/data/ent/auditlog"
	"github.com/go-tangra/go-tangra-hr/internal/data/ent/leaveallowance"
	"github.com/go-tangra/go-tangra-hr/internal/data/ent/leaverequest"
	"github.com/go-tangra/go-tangra-hr/internal/data/ent/predicate"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAbsenceType    = "AbsenceType"
	TypeAuditLog       = "AuditLog"
	TypeLeaveAllowance = "LeaveAllowance"
	TypeLeaveRequest   = "LeaveRequest"
)

// AbsenceTypeMutation represents an operation that mutates the AbsenceType nodes in the graph.
type AbsenceTypeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	create_by               *uint32
	addcreate_by            *int32
	update_by               *uint32
	addupdate_by            *int32
	create_time             *time.Time
	update_time             *time.Time
	delete_time             *time.Time
	tenant_id               *uint32
	addtenant_id            *int32
	name                    *string
	description             *string
	color                   *string
	icon                    *string
	deducts_from_allowance  *bool
	requires_approval       *bool
	is_active               *bool
	sort_order              *int
	addsort_order           *int
	metadata                *map[string]interface{}
	requires_signing        *bool
	signing_template_id     *string
	clearedFields           map[string]struct{}
	leave_allowances        map[string]struct{}
	removedleave_allowances map[string]struct{}
	clearedleave_allowances bool
	leave_requests          map[string]struct{}
	removedleave_requests   map[string]struct{}
	clearedleave_requests   bool
	done                    bool
	oldValue                func(context.Context) (*AbsenceType, error)
	predicates              []predicate.AbsenceType
}

var _ ent.Mutation = (*AbsenceTypeMutation)(nil)

// absencetypeOption allows management of the mutation configuration using functional options.
type absencetypeOption func(*AbsenceTypeMutation)

// newAbsenceTypeMutation creates new mutation for the AbsenceType entity.
func newAbsenceTypeMutation(c config, op Op, opts ...absencetypeOption) *AbsenceTypeMutation {
	m := &AbsenceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAbsenceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAbsenceTypeID sets the ID field of the mutation.
func withAbsenceTypeID(id string) absencetypeOption {
	return func(m *AbsenceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *AbsenceType
		)
		m.oldValue = func(ctx context.Context) (*AbsenceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AbsenceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAbsenceType sets the old AbsenceType of the mutation.
func withAbsenceType(node *AbsenceType) absencetypeOption {
	return func(m *AbsenceTypeMutation) {
		m.oldValue = func(context.Context) (*AbsenceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AbsenceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AbsenceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AbsenceType entities.
func (m *AbsenceTypeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AbsenceTypeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AbsenceTypeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AbsenceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *AbsenceTypeMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *AbsenceTypeMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *AbsenceTypeMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *AbsenceTypeMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *AbsenceTypeMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[absencetype.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *AbsenceTypeMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *AbsenceTypeMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, absencetype.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *AbsenceTypeMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *AbsenceTypeMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *AbsenceTypeMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *AbsenceTypeMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *AbsenceTypeMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[absencetype.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *AbsenceTypeMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *AbsenceTypeMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, absencetype.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *AbsenceTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AbsenceTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AbsenceTypeMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[absencetype.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AbsenceTypeMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AbsenceTypeMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, absencetype.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AbsenceTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AbsenceTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AbsenceTypeMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[absencetype.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AbsenceTypeMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AbsenceTypeMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, absencetype.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *AbsenceTypeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AbsenceTypeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AbsenceTypeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[absencetype.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AbsenceTypeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AbsenceTypeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, absencetype.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *AbsenceTypeMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AbsenceTypeMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *AbsenceTypeMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AbsenceTypeMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AbsenceTypeMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[absencetype.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AbsenceTypeMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AbsenceTypeMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, absencetype.FieldTenantID)
}

// SetName sets the "name" field.
func (m *AbsenceTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AbsenceTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AbsenceTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AbsenceTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AbsenceTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AbsenceTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[absencetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AbsenceTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AbsenceTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, absencetype.FieldDescription)
}

// SetColor sets the "color" field.
func (m *AbsenceTypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *AbsenceTypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *AbsenceTypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[absencetype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *AbsenceTypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *AbsenceTypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, absencetype.FieldColor)
}

// SetIcon sets the "icon" field.
func (m *AbsenceTypeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *AbsenceTypeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *AbsenceTypeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[absencetype.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *AbsenceTypeMutation) IconCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *AbsenceTypeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, absencetype.FieldIcon)
}

// SetDeductsFromAllowance sets the "deducts_from_allowance" field.
func (m *AbsenceTypeMutation) SetDeductsFromAllowance(b bool) {
	m.deducts_from_allowance = &b
}

// DeductsFromAllowance returns the value of the "deducts_from_allowance" field in the mutation.
func (m *AbsenceTypeMutation) DeductsFromAllowance() (r bool, exists bool) {
	v := m.deducts_from_allowance
	if v == nil {
		return
	}
	return *v, true
}

// OldDeductsFromAllowance returns the old "deducts_from_allowance" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldDeductsFromAllowance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeductsFromAllowance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeductsFromAllowance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeductsFromAllowance: %w", err)
	}
	return oldValue.DeductsFromAllowance, nil
}

// ResetDeductsFromAllowance resets all changes to the "deducts_from_allowance" field.
func (m *AbsenceTypeMutation) ResetDeductsFromAllowance() {
	m.deducts_from_allowance = nil
}

// SetRequiresApproval sets the "requires_approval" field.
func (m *AbsenceTypeMutation) SetRequiresApproval(b bool) {
	m.requires_approval = &b
}

// RequiresApproval returns the value of the "requires_approval" field in the mutation.
func (m *AbsenceTypeMutation) RequiresApproval() (r bool, exists bool) {
	v := m.requires_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresApproval returns the old "requires_approval" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldRequiresApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresApproval: %w", err)
	}
	return oldValue.RequiresApproval, nil
}

// ResetRequiresApproval resets all changes to the "requires_approval" field.
func (m *AbsenceTypeMutation) ResetRequiresApproval() {
	m.requires_approval = nil
}

// SetIsActive sets the "is_active" field.
func (m *AbsenceTypeMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AbsenceTypeMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AbsenceTypeMutation) ResetIsActive() {
	m.is_active = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *AbsenceTypeMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *AbsenceTypeMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *AbsenceTypeMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *AbsenceTypeMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *AbsenceTypeMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetMetadata sets the "metadata" field.
func (m *AbsenceTypeMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AbsenceTypeMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AbsenceTypeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[absencetype.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AbsenceTypeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AbsenceTypeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, absencetype.FieldMetadata)
}

// SetRequiresSigning sets the "requires_signing" field.
func (m *AbsenceTypeMutation) SetRequiresSigning(b bool) {
	m.requires_signing = &b
}

// RequiresSigning returns the value of the "requires_signing" field in the mutation.
func (m *AbsenceTypeMutation) RequiresSigning() (r bool, exists bool) {
	v := m.requires_signing
	if v == nil {
		return
	}
	return *v, true
}

// OldRequiresSigning returns the old "requires_signing" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldRequiresSigning(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequiresSigning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequiresSigning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequiresSigning: %w", err)
	}
	return oldValue.RequiresSigning, nil
}

// ResetRequiresSigning resets all changes to the "requires_signing" field.
func (m *AbsenceTypeMutation) ResetRequiresSigning() {
	m.requires_signing = nil
}

// SetSigningTemplateID sets the "signing_template_id" field.
func (m *AbsenceTypeMutation) SetSigningTemplateID(s string) {
	m.signing_template_id = &s
}

// SigningTemplateID returns the value of the "signing_template_id" field in the mutation.
func (m *AbsenceTypeMutation) SigningTemplateID() (r string, exists bool) {
	v := m.signing_template_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningTemplateID returns the old "signing_template_id" field's value of the AbsenceType entity.
// If the AbsenceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AbsenceTypeMutation) OldSigningTemplateID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningTemplateID: %w", err)
	}
	return oldValue.SigningTemplateID, nil
}

// ClearSigningTemplateID clears the value of the "signing_template_id" field.
func (m *AbsenceTypeMutation) ClearSigningTemplateID() {
	m.signing_template_id = nil
	m.clearedFields[absencetype.FieldSigningTemplateID] = struct{}{}
}

// SigningTemplateIDCleared returns if the "signing_template_id" field was cleared in this mutation.
func (m *AbsenceTypeMutation) SigningTemplateIDCleared() bool {
	_, ok := m.clearedFields[absencetype.FieldSigningTemplateID]
	return ok
}

// ResetSigningTemplateID resets all changes to the "signing_template_id" field.
func (m *AbsenceTypeMutation) ResetSigningTemplateID() {
	m.signing_template_id = nil
	delete(m.clearedFields, absencetype.FieldSigningTemplateID)
}

// AddLeaveAllowanceIDs adds the "leave_allowances" edge to the LeaveAllowance entity by ids.
func (m *AbsenceTypeMutation) AddLeaveAllowanceIDs(ids ...string) {
	if m.leave_allowances == nil {
		m.leave_allowances = make(map[string]struct{})
	}
	for i := range ids {
		m.leave_allowances[ids[i]] = struct{}{}
	}
}

// ClearLeaveAllowances clears the "leave_allowances" edge to the LeaveAllowance entity.
func (m *AbsenceTypeMutation) ClearLeaveAllowances() {
	m.clearedleave_allowances = true
}

// LeaveAllowancesCleared reports if the "leave_allowances" edge to the LeaveAllowance entity was cleared.
func (m *AbsenceTypeMutation) LeaveAllowancesCleared() bool {
	return m.clearedleave_allowances
}

// RemoveLeaveAllowanceIDs removes the "leave_allowances" edge to the LeaveAllowance entity by IDs.
func (m *AbsenceTypeMutation) RemoveLeaveAllowanceIDs(ids ...string) {
	if m.removedleave_allowances == nil {
		m.removedleave_allowances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.leave_allowances, ids[i])
		m.removedleave_allowances[ids[i]] = struct{}{}
	}
}

// RemovedLeaveAllowances returns the removed IDs of the "leave_allowances" edge to the LeaveAllowance entity.
func (m *AbsenceTypeMutation) RemovedLeaveAllowancesIDs() (ids []string) {
	for id := range m.removedleave_allowances {
		ids = append(ids, id)
	}
	return
}

// LeaveAllowancesIDs returns the "leave_allowances" edge IDs in the mutation.
func (m *AbsenceTypeMutation) LeaveAllowancesIDs() (ids []string) {
	for id := range m.leave_allowances {
		ids = append(ids, id)
	}
	return
}

// ResetLeaveAllowances resets all changes to the "leave_allowances" edge.
func (m *AbsenceTypeMutation) ResetLeaveAllowances() {
	m.leave_allowances = nil
	m.clearedleave_allowances = false
	m.removedleave_allowances = nil
}

// AddLeaveRequestIDs adds the "leave_requests" edge to the LeaveRequest entity by ids.
func (m *AbsenceTypeMutation) AddLeaveRequestIDs(ids ...string) {
	if m.leave_requests == nil {
		m.leave_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.leave_requests[ids[i]] = struct{}{}
	}
}

// ClearLeaveRequests clears the "leave_requests" edge to the LeaveRequest entity.
func (m *AbsenceTypeMutation) ClearLeaveRequests() {
	m.clearedleave_requests = true
}

// LeaveRequestsCleared reports if the "leave_requests" edge to the LeaveRequest entity was cleared.
func (m *AbsenceTypeMutation) LeaveRequestsCleared() bool {
	return m.clearedleave_requests
}

// RemoveLeaveRequestIDs removes the "leave_requests" edge to the LeaveRequest entity by IDs.
func (m *AbsenceTypeMutation) RemoveLeaveRequestIDs(ids ...string) {
	if m.removedleave_requests == nil {
		m.removedleave_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.leave_requests, ids[i])
		m.removedleave_requests[ids[i]] = struct{}{}
	}
}

// RemovedLeaveRequests returns the removed IDs of the "leave_requests" edge to the LeaveRequest entity.
func (m *AbsenceTypeMutation) RemovedLeaveRequestsIDs() (ids []string) {
	for id := range m.removedleave_requests {
		ids = append(ids, id)
	}
	return
}

// LeaveRequestsIDs returns the "leave_requests" edge IDs in the mutation.
func (m *AbsenceTypeMutation) LeaveRequestsIDs() (ids []string) {
	for id := range m.leave_requests {
		ids = append(ids, id)
	}
	return
}

// ResetLeaveRequests resets all changes to the "leave_requests" edge.
func (m *AbsenceTypeMutation) ResetLeaveRequests() {
	m.leave_requests = nil
	m.clearedleave_requests = false
	m.removedleave_requests = nil
}

// Where appends a list predicates to the AbsenceTypeMutation builder.
func (m *AbsenceTypeMutation) Where(ps ...predicate.AbsenceType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AbsenceTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AbsenceTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AbsenceType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AbsenceTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AbsenceTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AbsenceType).
func (m *AbsenceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AbsenceTypeMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.create_by != nil {
		fields = append(fields, absencetype.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, absencetype.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, absencetype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, absencetype.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, absencetype.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, absencetype.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, absencetype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, absencetype.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, absencetype.FieldColor)
	}
	if m.icon != nil {
		fields = append(fields, absencetype.FieldIcon)
	}
	if m.deducts_from_allowance != nil {
		fields = append(fields, absencetype.FieldDeductsFromAllowance)
	}
	if m.requires_approval != nil {
		fields = append(fields, absencetype.FieldRequiresApproval)
	}
	if m.is_active != nil {
		fields = append(fields, absencetype.FieldIsActive)
	}
	if m.sort_order != nil {
		fields = append(fields, absencetype.FieldSortOrder)
	}
	if m.metadata != nil {
		fields = append(fields, absencetype.FieldMetadata)
	}
	if m.requires_signing != nil {
		fields = append(fields, absencetype.FieldRequiresSigning)
	}
	if m.signing_template_id != nil {
		fields = append(fields, absencetype.FieldSigningTemplateID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AbsenceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case absencetype.FieldCreateBy:
		return m.CreateBy()
	case absencetype.FieldUpdateBy:
		return m.UpdateBy()
	case absencetype.FieldCreateTime:
		return m.CreateTime()
	case absencetype.FieldUpdateTime:
		return m.UpdateTime()
	case absencetype.FieldDeleteTime:
		return m.DeleteTime()
	case absencetype.FieldTenantID:
		return m.TenantID()
	case absencetype.FieldName:
		return m.Name()
	case absencetype.FieldDescription:
		return m.Description()
	case absencetype.FieldColor:
		return m.Color()
	case absencetype.FieldIcon:
		return m.Icon()
	case absencetype.FieldDeductsFromAllowance:
		return m.DeductsFromAllowance()
	case absencetype.FieldRequiresApproval:
		return m.RequiresApproval()
	case absencetype.FieldIsActive:
		return m.IsActive()
	case absencetype.FieldSortOrder:
		return m.SortOrder()
	case absencetype.FieldMetadata:
		return m.Metadata()
	case absencetype.FieldRequiresSigning:
		return m.RequiresSigning()
	case absencetype.FieldSigningTemplateID:
		return m.SigningTemplateID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AbsenceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case absencetype.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case absencetype.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case absencetype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case absencetype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case absencetype.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case absencetype.FieldTenantID:
		return m.OldTenantID(ctx)
	case absencetype.FieldName:
		return m.OldName(ctx)
	case absencetype.FieldDescription:
		return m.OldDescription(ctx)
	case absencetype.FieldColor:
		return m.OldColor(ctx)
	case absencetype.FieldIcon:
		return m.OldIcon(ctx)
	case absencetype.FieldDeductsFromAllowance:
		return m.OldDeductsFromAllowance(ctx)
	case absencetype.FieldRequiresApproval:
		return m.OldRequiresApproval(ctx)
	case absencetype.FieldIsActive:
		return m.OldIsActive(ctx)
	case absencetype.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case absencetype.FieldMetadata:
		return m.OldMetadata(ctx)
	case absencetype.FieldRequiresSigning:
		return m.OldRequiresSigning(ctx)
	case absencetype.FieldSigningTemplateID:
		return m.OldSigningTemplateID(ctx)
	}
	return nil, fmt.Errorf("unknown AbsenceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbsenceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case absencetype.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case absencetype.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case absencetype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case absencetype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case absencetype.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case absencetype.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case absencetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case absencetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case absencetype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case absencetype.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case absencetype.FieldDeductsFromAllowance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeductsFromAllowance(v)
		return nil
	case absencetype.FieldRequiresApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresApproval(v)
		return nil
	case absencetype.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case absencetype.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case absencetype.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case absencetype.FieldRequiresSigning:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequiresSigning(v)
		return nil
	case absencetype.FieldSigningTemplateID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningTemplateID(v)
		return nil
	}
	return fmt.Errorf("unknown AbsenceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AbsenceTypeMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, absencetype.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, absencetype.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, absencetype.FieldTenantID)
	}
	if m.addsort_order != nil {
		fields = append(fields, absencetype.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AbsenceTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case absencetype.FieldCreateBy:
		return m.AddedCreateBy()
	case absencetype.FieldUpdateBy:
		return m.AddedUpdateBy()
	case absencetype.FieldTenantID:
		return m.AddedTenantID()
	case absencetype.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AbsenceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case absencetype.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case absencetype.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case absencetype.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case absencetype.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown AbsenceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AbsenceTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(absencetype.FieldCreateBy) {
		fields = append(fields, absencetype.FieldCreateBy)
	}
	if m.FieldCleared(absencetype.FieldUpdateBy) {
		fields = append(fields, absencetype.FieldUpdateBy)
	}
	if m.FieldCleared(absencetype.FieldCreateTime) {
		fields = append(fields, absencetype.FieldCreateTime)
	}
	if m.FieldCleared(absencetype.FieldUpdateTime) {
		fields = append(fields, absencetype.FieldUpdateTime)
	}
	if m.FieldCleared(absencetype.FieldDeleteTime) {
		fields = append(fields, absencetype.FieldDeleteTime)
	}
	if m.FieldCleared(absencetype.FieldTenantID) {
		fields = append(fields, absencetype.FieldTenantID)
	}
	if m.FieldCleared(absencetype.FieldDescription) {
		fields = append(fields, absencetype.FieldDescription)
	}
	if m.FieldCleared(absencetype.FieldColor) {
		fields = append(fields, absencetype.FieldColor)
	}
	if m.FieldCleared(absencetype.FieldIcon) {
		fields = append(fields, absencetype.FieldIcon)
	}
	if m.FieldCleared(absencetype.FieldMetadata) {
		fields = append(fields, absencetype.FieldMetadata)
	}
	if m.FieldCleared(absencetype.FieldSigningTemplateID) {
		fields = append(fields, absencetype.FieldSigningTemplateID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AbsenceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AbsenceTypeMutation) ClearField(name string) error {
	switch name {
	case absencetype.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case absencetype.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case absencetype.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case absencetype.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case absencetype.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case absencetype.FieldTenantID:
		m.ClearTenantID()
		return nil
	case absencetype.FieldDescription:
		m.ClearDescription()
		return nil
	case absencetype.FieldColor:
		m.ClearColor()
		return nil
	case absencetype.FieldIcon:
		m.ClearIcon()
		return nil
	case absencetype.FieldMetadata:
		m.ClearMetadata()
		return nil
	case absencetype.FieldSigningTemplateID:
		m.ClearSigningTemplateID()
		return nil
	}
	return fmt.Errorf("unknown AbsenceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AbsenceTypeMutation) ResetField(name string) error {
	switch name {
	case absencetype.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case absencetype.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case absencetype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case absencetype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case absencetype.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case absencetype.FieldTenantID:
		m.ResetTenantID()
		return nil
	case absencetype.FieldName:
		m.ResetName()
		return nil
	case absencetype.FieldDescription:
		m.ResetDescription()
		return nil
	case absencetype.FieldColor:
		m.ResetColor()
		return nil
	case absencetype.FieldIcon:
		m.ResetIcon()
		return nil
	case absencetype.FieldDeductsFromAllowance:
		m.ResetDeductsFromAllowance()
		return nil
	case absencetype.FieldRequiresApproval:
		m.ResetRequiresApproval()
		return nil
	case absencetype.FieldIsActive:
		m.ResetIsActive()
		return nil
	case absencetype.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case absencetype.FieldMetadata:
		m.ResetMetadata()
		return nil
	case absencetype.FieldRequiresSigning:
		m.ResetRequiresSigning()
		return nil
	case absencetype.FieldSigningTemplateID:
		m.ResetSigningTemplateID()
		return nil
	}
	return fmt.Errorf("unknown AbsenceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AbsenceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.leave_allowances != nil {
		edges = append(edges, absencetype.EdgeLeaveAllowances)
	}
	if m.leave_requests != nil {
		edges = append(edges, absencetype.EdgeLeaveRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AbsenceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case absencetype.EdgeLeaveAllowances:
		ids := make([]ent.Value, 0, len(m.leave_allowances))
		for id := range m.leave_allowances {
			ids = append(ids, id)
		}
		return ids
	case absencetype.EdgeLeaveRequests:
		ids := make([]ent.Value, 0, len(m.leave_requests))
		for id := range m.leave_requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AbsenceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedleave_allowances != nil {
		edges = append(edges, absencetype.EdgeLeaveAllowances)
	}
	if m.removedleave_requests != nil {
		edges = append(edges, absencetype.EdgeLeaveRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AbsenceTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case absencetype.EdgeLeaveAllowances:
		ids := make([]ent.Value, 0, len(m.removedleave_allowances))
		for id := range m.removedleave_allowances {
			ids = append(ids, id)
		}
		return ids
	case absencetype.EdgeLeaveRequests:
		ids := make([]ent.Value, 0, len(m.removedleave_requests))
		for id := range m.removedleave_requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AbsenceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedleave_allowances {
		edges = append(edges, absencetype.EdgeLeaveAllowances)
	}
	if m.clearedleave_requests {
		edges = append(edges, absencetype.EdgeLeaveRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AbsenceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case absencetype.EdgeLeaveAllowances:
		return m.clearedleave_allowances
	case absencetype.EdgeLeaveRequests:
		return m.clearedleave_requests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AbsenceTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AbsenceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AbsenceTypeMutation) ResetEdge(name string) error {
	switch name {
	case absencetype.EdgeLeaveAllowances:
		m.ResetLeaveAllowances()
		return nil
	case absencetype.EdgeLeaveRequests:
		m.ResetLeaveRequests()
		return nil
	}
	return fmt.Errorf("unknown AbsenceType edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint32
	create_time          *time.Time
	update_time          *time.Time
	delete_time          *time.Time
	tenant_id            *uint32
	addtenant_id         *int32
	audit_id             *string
	request_id           *string
	operation            *string
	service_name         *string
	client_id            *string
	client_common_name   *string
	client_organization  *string
	client_serial_number *string
	is_authenticated     *bool
	success              *bool
	error_code           *int32
	adderror_code        *int32
	error_message        *string
	latency_ms           *int64
	addlatency_ms        *int64
	peer_address         *string
	geo_location         *map[string]string
	log_hash             *string
	signature            *[]byte
	metadata             *map[string]string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*AuditLog, error)
	predicates           []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id uint32) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AuditLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AuditLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *AuditLogMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[auditlog.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *AuditLogMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AuditLogMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, auditlog.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *AuditLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AuditLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *AuditLogMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[auditlog.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *AuditLogMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AuditLogMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, auditlog.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *AuditLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AuditLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AuditLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[auditlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AuditLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AuditLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, auditlog.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *AuditLogMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AuditLogMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *AuditLogMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *AuditLogMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *AuditLogMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[auditlog.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *AuditLogMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AuditLogMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, auditlog.FieldTenantID)
}

// SetAuditID sets the "audit_id" field.
func (m *AuditLogMutation) SetAuditID(s string) {
	m.audit_id = &s
}

// AuditID returns the value of the "audit_id" field in the mutation.
func (m *AuditLogMutation) AuditID() (r string, exists bool) {
	v := m.audit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuditID returns the old "audit_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAuditID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuditID: %w", err)
	}
	return oldValue.AuditID, nil
}

// ResetAuditID resets all changes to the "audit_id" field.
func (m *AuditLogMutation) ResetAuditID() {
	m.audit_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *AuditLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *AuditLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ClearRequestID clears the value of the "request_id" field.
func (m *AuditLogMutation) ClearRequestID() {
	m.request_id = nil
	m.clearedFields[auditlog.FieldRequestID] = struct{}{}
}

// RequestIDCleared returns if the "request_id" field was cleared in this mutation.
func (m *AuditLogMutation) RequestIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestID]
	return ok
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *AuditLogMutation) ResetRequestID() {
	m.request_id = nil
	delete(m.clearedFields, auditlog.FieldRequestID)
}

// SetOperation sets the "operation" field.
func (m *AuditLogMutation) SetOperation(s string) {
	m.operation = &s
}

// Operation returns the value of the "operation" field in the mutation.
func (m *AuditLogMutation) Operation() (r string, exists bool) {
	v := m.operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "operation" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldOperation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// ResetOperation resets all changes to the "operation" field.
func (m *AuditLogMutation) ResetOperation() {
	m.operation = nil
}

// SetServiceName sets the "service_name" field.
func (m *AuditLogMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *AuditLogMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *AuditLogMutation) ResetServiceName() {
	m.service_name = nil
}

// SetClientID sets the "client_id" field.
func (m *AuditLogMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *AuditLogMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *AuditLogMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[auditlog.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *AuditLogMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *AuditLogMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, auditlog.FieldClientID)
}

// SetClientCommonName sets the "client_common_name" field.
func (m *AuditLogMutation) SetClientCommonName(s string) {
	m.client_common_name = &s
}

// ClientCommonName returns the value of the "client_common_name" field in the mutation.
func (m *AuditLogMutation) ClientCommonName() (r string, exists bool) {
	v := m.client_common_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCommonName returns the old "client_common_name" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientCommonName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCommonName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCommonName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCommonName: %w", err)
	}
	return oldValue.ClientCommonName, nil
}

// ClearClientCommonName clears the value of the "client_common_name" field.
func (m *AuditLogMutation) ClearClientCommonName() {
	m.client_common_name = nil
	m.clearedFields[auditlog.FieldClientCommonName] = struct{}{}
}

// ClientCommonNameCleared returns if the "client_common_name" field was cleared in this mutation.
func (m *AuditLogMutation) ClientCommonNameCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientCommonName]
	return ok
}

// ResetClientCommonName resets all changes to the "client_common_name" field.
func (m *AuditLogMutation) ResetClientCommonName() {
	m.client_common_name = nil
	delete(m.clearedFields, auditlog.FieldClientCommonName)
}

// SetClientOrganization sets the "client_organization" field.
func (m *AuditLogMutation) SetClientOrganization(s string) {
	m.client_organization = &s
}

// ClientOrganization returns the value of the "client_organization" field in the mutation.
func (m *AuditLogMutation) ClientOrganization() (r string, exists bool) {
	v := m.client_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOrganization returns the old "client_organization" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOrganization: %w", err)
	}
	return oldValue.ClientOrganization, nil
}

// ClearClientOrganization clears the value of the "client_organization" field.
func (m *AuditLogMutation) ClearClientOrganization() {
	m.client_organization = nil
	m.clearedFields[auditlog.FieldClientOrganization] = struct{}{}
}

// ClientOrganizationCleared returns if the "client_organization" field was cleared in this mutation.
func (m *AuditLogMutation) ClientOrganizationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientOrganization]
	return ok
}

// ResetClientOrganization resets all changes to the "client_organization" field.
func (m *AuditLogMutation) ResetClientOrganization() {
	m.client_organization = nil
	delete(m.clearedFields, auditlog.FieldClientOrganization)
}

// SetClientSerialNumber sets the "client_serial_number" field.
func (m *AuditLogMutation) SetClientSerialNumber(s string) {
	m.client_serial_number = &s
}

// ClientSerialNumber returns the value of the "client_serial_number" field in the mutation.
func (m *AuditLogMutation) ClientSerialNumber() (r string, exists bool) {
	v := m.client_serial_number
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSerialNumber returns the old "client_serial_number" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldClientSerialNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSerialNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSerialNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSerialNumber: %w", err)
	}
	return oldValue.ClientSerialNumber, nil
}

// ClearClientSerialNumber clears the value of the "client_serial_number" field.
func (m *AuditLogMutation) ClearClientSerialNumber() {
	m.client_serial_number = nil
	m.clearedFields[auditlog.FieldClientSerialNumber] = struct{}{}
}

// ClientSerialNumberCleared returns if the "client_serial_number" field was cleared in this mutation.
func (m *AuditLogMutation) ClientSerialNumberCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldClientSerialNumber]
	return ok
}

// ResetClientSerialNumber resets all changes to the "client_serial_number" field.
func (m *AuditLogMutation) ResetClientSerialNumber() {
	m.client_serial_number = nil
	delete(m.clearedFields, auditlog.FieldClientSerialNumber)
}

// SetIsAuthenticated sets the "is_authenticated" field.
func (m *AuditLogMutation) SetIsAuthenticated(b bool) {
	m.is_authenticated = &b
}

// IsAuthenticated returns the value of the "is_authenticated" field in the mutation.
func (m *AuditLogMutation) IsAuthenticated() (r bool, exists bool) {
	v := m.is_authenticated
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAuthenticated returns the old "is_authenticated" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIsAuthenticated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAuthenticated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAuthenticated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAuthenticated: %w", err)
	}
	return oldValue.IsAuthenticated, nil
}

// ResetIsAuthenticated resets all changes to the "is_authenticated" field.
func (m *AuditLogMutation) ResetIsAuthenticated() {
	m.is_authenticated = nil
}

// SetSuccess sets the "success" field.
func (m *AuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *AuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *AuditLogMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorCode sets the "error_code" field.
func (m *AuditLogMutation) SetErrorCode(i int32) {
	m.error_code = &i
	m.adderror_code = nil
}

// ErrorCode returns the value of the "error_code" field in the mutation.
func (m *AuditLogMutation) ErrorCode() (r int32, exists bool) {
	v := m.error_code
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "error_code" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorCode(ctx context.Context) (v *int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// AddErrorCode adds i to the "error_code" field.
func (m *AuditLogMutation) AddErrorCode(i int32) {
	if m.adderror_code != nil {
		*m.adderror_code += i
	} else {
		m.adderror_code = &i
	}
}

// AddedErrorCode returns the value that was added to the "error_code" field in this mutation.
func (m *AuditLogMutation) AddedErrorCode() (r int32, exists bool) {
	v := m.adderror_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearErrorCode clears the value of the "error_code" field.
func (m *AuditLogMutation) ClearErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	m.clearedFields[auditlog.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "error_code" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "error_code" field.
func (m *AuditLogMutation) ResetErrorCode() {
	m.error_code = nil
	m.adderror_code = nil
	delete(m.clearedFields, auditlog.FieldErrorCode)
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetLatencyMs sets the "latency_ms" field.
func (m *AuditLogMutation) SetLatencyMs(i int64) {
	m.latency_ms = &i
	m.addlatency_ms = nil
}

// LatencyMs returns the value of the "latency_ms" field in the mutation.
func (m *AuditLogMutation) LatencyMs() (r int64, exists bool) {
	v := m.latency_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldLatencyMs returns the old "latency_ms" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLatencyMs(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatencyMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatencyMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatencyMs: %w", err)
	}
	return oldValue.LatencyMs, nil
}

// AddLatencyMs adds i to the "latency_ms" field.
func (m *AuditLogMutation) AddLatencyMs(i int64) {
	if m.addlatency_ms != nil {
		*m.addlatency_ms += i
	} else {
		m.addlatency_ms = &i
	}
}

// AddedLatencyMs returns the value that was added to the "latency_ms" field in this mutation.
func (m *AuditLogMutation) AddedLatencyMs() (r int64, exists bool) {
	v := m.addlatency_ms
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatencyMs resets all changes to the "latency_ms" field.
func (m *AuditLogMutation) ResetLatencyMs() {
	m.latency_ms = nil
	m.addlatency_ms = nil
}

// SetPeerAddress sets the "peer_address" field.
func (m *AuditLogMutation) SetPeerAddress(s string) {
	m.peer_address = &s
}

// PeerAddress returns the value of the "peer_address" field in the mutation.
func (m *AuditLogMutation) PeerAddress() (r string, exists bool) {
	v := m.peer_address
	if v == nil {
		return
	}
	return *v, true
}

// OldPeerAddress returns the old "peer_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldPeerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeerAddress: %w", err)
	}
	return oldValue.PeerAddress, nil
}

// ClearPeerAddress clears the value of the "peer_address" field.
func (m *AuditLogMutation) ClearPeerAddress() {
	m.peer_address = nil
	m.clearedFields[auditlog.FieldPeerAddress] = struct{}{}
}

// PeerAddressCleared returns if the "peer_address" field was cleared in this mutation.
func (m *AuditLogMutation) PeerAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldPeerAddress]
	return ok
}

// ResetPeerAddress resets all changes to the "peer_address" field.
func (m *AuditLogMutation) ResetPeerAddress() {
	m.peer_address = nil
	delete(m.clearedFields, auditlog.FieldPeerAddress)
}

// SetGeoLocation sets the "geo_location" field.
func (m *AuditLogMutation) SetGeoLocation(value map[string]string) {
	m.geo_location = &value
}

// GeoLocation returns the value of the "geo_location" field in the mutation.
func (m *AuditLogMutation) GeoLocation() (r map[string]string, exists bool) {
	v := m.geo_location
	if v == nil {
		return
	}
	return *v, true
}

// OldGeoLocation returns the old "geo_location" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldGeoLocation(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeoLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeoLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeoLocation: %w", err)
	}
	return oldValue.GeoLocation, nil
}

// ClearGeoLocation clears the value of the "geo_location" field.
func (m *AuditLogMutation) ClearGeoLocation() {
	m.geo_location = nil
	m.clearedFields[auditlog.FieldGeoLocation] = struct{}{}
}

// GeoLocationCleared returns if the "geo_location" field was cleared in this mutation.
func (m *AuditLogMutation) GeoLocationCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldGeoLocation]
	return ok
}

// ResetGeoLocation resets all changes to the "geo_location" field.
func (m *AuditLogMutation) ResetGeoLocation() {
	m.geo_location = nil
	delete(m.clearedFields, auditlog.FieldGeoLocation)
}

// SetLogHash sets the "log_hash" field.
func (m *AuditLogMutation) SetLogHash(s string) {
	m.log_hash = &s
}

// LogHash returns the value of the "log_hash" field in the mutation.
func (m *AuditLogMutation) LogHash() (r string, exists bool) {
	v := m.log_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldLogHash returns the old "log_hash" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldLogHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogHash: %w", err)
	}
	return oldValue.LogHash, nil
}

// ClearLogHash clears the value of the "log_hash" field.
func (m *AuditLogMutation) ClearLogHash() {
	m.log_hash = nil
	m.clearedFields[auditlog.FieldLogHash] = struct{}{}
}

// LogHashCleared returns if the "log_hash" field was cleared in this mutation.
func (m *AuditLogMutation) LogHashCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldLogHash]
	return ok
}

// ResetLogHash resets all changes to the "log_hash" field.
func (m *AuditLogMutation) ResetLogHash() {
	m.log_hash = nil
	delete(m.clearedFields, auditlog.FieldLogHash)
}

// SetSignature sets the "signature" field.
func (m *AuditLogMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *AuditLogMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *AuditLogMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[auditlog.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *AuditLogMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *AuditLogMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, auditlog.FieldSignature)
}

// SetMetadata sets the "metadata" field.
func (m *AuditLogMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuditLogMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AuditLogMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[auditlog.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AuditLogMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuditLogMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, auditlog.FieldMetadata)
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.create_time != nil {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.audit_id != nil {
		fields = append(fields, auditlog.FieldAuditID)
	}
	if m.request_id != nil {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.operation != nil {
		fields = append(fields, auditlog.FieldOperation)
	}
	if m.service_name != nil {
		fields = append(fields, auditlog.FieldServiceName)
	}
	if m.client_id != nil {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.client_common_name != nil {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.client_organization != nil {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.client_serial_number != nil {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.is_authenticated != nil {
		fields = append(fields, auditlog.FieldIsAuthenticated)
	}
	if m.success != nil {
		fields = append(fields, auditlog.FieldSuccess)
	}
	if m.error_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.latency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	if m.peer_address != nil {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.geo_location != nil {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.log_hash != nil {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.signature != nil {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.metadata != nil {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.CreateTime()
	case auditlog.FieldUpdateTime:
		return m.UpdateTime()
	case auditlog.FieldDeleteTime:
		return m.DeleteTime()
	case auditlog.FieldTenantID:
		return m.TenantID()
	case auditlog.FieldAuditID:
		return m.AuditID()
	case auditlog.FieldRequestID:
		return m.RequestID()
	case auditlog.FieldOperation:
		return m.Operation()
	case auditlog.FieldServiceName:
		return m.ServiceName()
	case auditlog.FieldClientID:
		return m.ClientID()
	case auditlog.FieldClientCommonName:
		return m.ClientCommonName()
	case auditlog.FieldClientOrganization:
		return m.ClientOrganization()
	case auditlog.FieldClientSerialNumber:
		return m.ClientSerialNumber()
	case auditlog.FieldIsAuthenticated:
		return m.IsAuthenticated()
	case auditlog.FieldSuccess:
		return m.Success()
	case auditlog.FieldErrorCode:
		return m.ErrorCode()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldLatencyMs:
		return m.LatencyMs()
	case auditlog.FieldPeerAddress:
		return m.PeerAddress()
	case auditlog.FieldGeoLocation:
		return m.GeoLocation()
	case auditlog.FieldLogHash:
		return m.LogHash()
	case auditlog.FieldSignature:
		return m.Signature()
	case auditlog.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case auditlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case auditlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case auditlog.FieldTenantID:
		return m.OldTenantID(ctx)
	case auditlog.FieldAuditID:
		return m.OldAuditID(ctx)
	case auditlog.FieldRequestID:
		return m.OldRequestID(ctx)
	case auditlog.FieldOperation:
		return m.OldOperation(ctx)
	case auditlog.FieldServiceName:
		return m.OldServiceName(ctx)
	case auditlog.FieldClientID:
		return m.OldClientID(ctx)
	case auditlog.FieldClientCommonName:
		return m.OldClientCommonName(ctx)
	case auditlog.FieldClientOrganization:
		return m.OldClientOrganization(ctx)
	case auditlog.FieldClientSerialNumber:
		return m.OldClientSerialNumber(ctx)
	case auditlog.FieldIsAuthenticated:
		return m.OldIsAuthenticated(ctx)
	case auditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case auditlog.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldLatencyMs:
		return m.OldLatencyMs(ctx)
	case auditlog.FieldPeerAddress:
		return m.OldPeerAddress(ctx)
	case auditlog.FieldGeoLocation:
		return m.OldGeoLocation(ctx)
	case auditlog.FieldLogHash:
		return m.OldLogHash(ctx)
	case auditlog.FieldSignature:
		return m.OldSignature(ctx)
	case auditlog.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case auditlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case auditlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case auditlog.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case auditlog.FieldAuditID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuditID(v)
		return nil
	case auditlog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case auditlog.FieldOperation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case auditlog.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case auditlog.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case auditlog.FieldClientCommonName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCommonName(v)
		return nil
	case auditlog.FieldClientOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOrganization(v)
		return nil
	case auditlog.FieldClientSerialNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSerialNumber(v)
		return nil
	case auditlog.FieldIsAuthenticated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAuthenticated(v)
		return nil
	case auditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatencyMs(v)
		return nil
	case auditlog.FieldPeerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeerAddress(v)
		return nil
	case auditlog.FieldGeoLocation:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeoLocation(v)
		return nil
	case auditlog.FieldLogHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogHash(v)
		return nil
	case auditlog.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case auditlog.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	var fields []string
	if m.addtenant_id != nil {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.adderror_code != nil {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.addlatency_ms != nil {
		fields = append(fields, auditlog.FieldLatencyMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldTenantID:
		return m.AddedTenantID()
	case auditlog.FieldErrorCode:
		return m.AddedErrorCode()
	case auditlog.FieldLatencyMs:
		return m.AddedLatencyMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case auditlog.FieldErrorCode:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrorCode(v)
		return nil
	case auditlog.FieldLatencyMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatencyMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldCreateTime) {
		fields = append(fields, auditlog.FieldCreateTime)
	}
	if m.FieldCleared(auditlog.FieldUpdateTime) {
		fields = append(fields, auditlog.FieldUpdateTime)
	}
	if m.FieldCleared(auditlog.FieldDeleteTime) {
		fields = append(fields, auditlog.FieldDeleteTime)
	}
	if m.FieldCleared(auditlog.FieldTenantID) {
		fields = append(fields, auditlog.FieldTenantID)
	}
	if m.FieldCleared(auditlog.FieldRequestID) {
		fields = append(fields, auditlog.FieldRequestID)
	}
	if m.FieldCleared(auditlog.FieldClientID) {
		fields = append(fields, auditlog.FieldClientID)
	}
	if m.FieldCleared(auditlog.FieldClientCommonName) {
		fields = append(fields, auditlog.FieldClientCommonName)
	}
	if m.FieldCleared(auditlog.FieldClientOrganization) {
		fields = append(fields, auditlog.FieldClientOrganization)
	}
	if m.FieldCleared(auditlog.FieldClientSerialNumber) {
		fields = append(fields, auditlog.FieldClientSerialNumber)
	}
	if m.FieldCleared(auditlog.FieldErrorCode) {
		fields = append(fields, auditlog.FieldErrorCode)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.FieldCleared(auditlog.FieldPeerAddress) {
		fields = append(fields, auditlog.FieldPeerAddress)
	}
	if m.FieldCleared(auditlog.FieldGeoLocation) {
		fields = append(fields, auditlog.FieldGeoLocation)
	}
	if m.FieldCleared(auditlog.FieldLogHash) {
		fields = append(fields, auditlog.FieldLogHash)
	}
	if m.FieldCleared(auditlog.FieldSignature) {
		fields = append(fields, auditlog.FieldSignature)
	}
	if m.FieldCleared(auditlog.FieldMetadata) {
		fields = append(fields, auditlog.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ClearTenantID()
		return nil
	case auditlog.FieldRequestID:
		m.ClearRequestID()
		return nil
	case auditlog.FieldClientID:
		m.ClearClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ClearClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ClearClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ClearClientSerialNumber()
		return nil
	case auditlog.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditlog.FieldPeerAddress:
		m.ClearPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ClearGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ClearLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ClearSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case auditlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case auditlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case auditlog.FieldTenantID:
		m.ResetTenantID()
		return nil
	case auditlog.FieldAuditID:
		m.ResetAuditID()
		return nil
	case auditlog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case auditlog.FieldOperation:
		m.ResetOperation()
		return nil
	case auditlog.FieldServiceName:
		m.ResetServiceName()
		return nil
	case auditlog.FieldClientID:
		m.ResetClientID()
		return nil
	case auditlog.FieldClientCommonName:
		m.ResetClientCommonName()
		return nil
	case auditlog.FieldClientOrganization:
		m.ResetClientOrganization()
		return nil
	case auditlog.FieldClientSerialNumber:
		m.ResetClientSerialNumber()
		return nil
	case auditlog.FieldIsAuthenticated:
		m.ResetIsAuthenticated()
		return nil
	case auditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case auditlog.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldLatencyMs:
		m.ResetLatencyMs()
		return nil
	case auditlog.FieldPeerAddress:
		m.ResetPeerAddress()
		return nil
	case auditlog.FieldGeoLocation:
		m.ResetGeoLocation()
		return nil
	case auditlog.FieldLogHash:
		m.ResetLogHash()
		return nil
	case auditlog.FieldSignature:
		m.ResetSignature()
		return nil
	case auditlog.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// LeaveAllowanceMutation represents an operation that mutates the LeaveAllowance nodes in the graph.
type LeaveAllowanceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	create_by           *uint32
	addcreate_by        *int32
	update_by           *uint32
	addupdate_by        *int32
	create_time         *time.Time
	update_time         *time.Time
	delete_time         *time.Time
	tenant_id           *uint32
	addtenant_id        *int32
	user_id             *uint32
	adduser_id          *int32
	user_name           *string
	year                *int
	addyear             *int
	total_days          *float64
	addtotal_days       *float64
	used_days           *float64
	addused_days        *float64
	carried_over        *float64
	addcarried_over     *float64
	notes               *string
	clearedFields       map[string]struct{}
	absence_type        *string
	clearedabsence_type bool
	done                bool
	oldValue            func(context.Context) (*LeaveAllowance, error)
	predicates          []predicate.LeaveAllowance
}

var _ ent.Mutation = (*LeaveAllowanceMutation)(nil)

// leaveallowanceOption allows management of the mutation configuration using functional options.
type leaveallowanceOption func(*LeaveAllowanceMutation)

// newLeaveAllowanceMutation creates new mutation for the LeaveAllowance entity.
func newLeaveAllowanceMutation(c config, op Op, opts ...leaveallowanceOption) *LeaveAllowanceMutation {
	m := &LeaveAllowanceMutation{
		config:        c,
		op:            op,
		typ:           TypeLeaveAllowance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaveAllowanceID sets the ID field of the mutation.
func withLeaveAllowanceID(id string) leaveallowanceOption {
	return func(m *LeaveAllowanceMutation) {
		var (
			err   error
			once  sync.Once
			value *LeaveAllowance
		)
		m.oldValue = func(ctx context.Context) (*LeaveAllowance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeaveAllowance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeaveAllowance sets the old LeaveAllowance of the mutation.
func withLeaveAllowance(node *LeaveAllowance) leaveallowanceOption {
	return func(m *LeaveAllowanceMutation) {
		m.oldValue = func(context.Context) (*LeaveAllowance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaveAllowanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaveAllowanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LeaveAllowance entities.
func (m *LeaveAllowanceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeaveAllowanceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeaveAllowanceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeaveAllowance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *LeaveAllowanceMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *LeaveAllowanceMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *LeaveAllowanceMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *LeaveAllowanceMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *LeaveAllowanceMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[leaveallowance.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *LeaveAllowanceMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, leaveallowance.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *LeaveAllowanceMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *LeaveAllowanceMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *LeaveAllowanceMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *LeaveAllowanceMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *LeaveAllowanceMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[leaveallowance.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *LeaveAllowanceMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, leaveallowance.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *LeaveAllowanceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LeaveAllowanceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *LeaveAllowanceMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[leaveallowance.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LeaveAllowanceMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, leaveallowance.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *LeaveAllowanceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LeaveAllowanceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *LeaveAllowanceMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[leaveallowance.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LeaveAllowanceMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, leaveallowance.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *LeaveAllowanceMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *LeaveAllowanceMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *LeaveAllowanceMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[leaveallowance.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *LeaveAllowanceMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, leaveallowance.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *LeaveAllowanceMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LeaveAllowanceMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *LeaveAllowanceMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *LeaveAllowanceMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LeaveAllowanceMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[leaveallowance.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LeaveAllowanceMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, leaveallowance.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *LeaveAllowanceMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LeaveAllowanceMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *LeaveAllowanceMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *LeaveAllowanceMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LeaveAllowanceMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetUserName sets the "user_name" field.
func (m *LeaveAllowanceMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *LeaveAllowanceMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *LeaveAllowanceMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[leaveallowance.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *LeaveAllowanceMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, leaveallowance.FieldUserName)
}

// SetAbsenceTypeID sets the "absence_type_id" field.
func (m *LeaveAllowanceMutation) SetAbsenceTypeID(s string) {
	m.absence_type = &s
}

// AbsenceTypeID returns the value of the "absence_type_id" field in the mutation.
func (m *LeaveAllowanceMutation) AbsenceTypeID() (r string, exists bool) {
	v := m.absence_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsenceTypeID returns the old "absence_type_id" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldAbsenceTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsenceTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsenceTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsenceTypeID: %w", err)
	}
	return oldValue.AbsenceTypeID, nil
}

// ResetAbsenceTypeID resets all changes to the "absence_type_id" field.
func (m *LeaveAllowanceMutation) ResetAbsenceTypeID() {
	m.absence_type = nil
}

// SetYear sets the "year" field.
func (m *LeaveAllowanceMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *LeaveAllowanceMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *LeaveAllowanceMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *LeaveAllowanceMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *LeaveAllowanceMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetTotalDays sets the "total_days" field.
func (m *LeaveAllowanceMutation) SetTotalDays(f float64) {
	m.total_days = &f
	m.addtotal_days = nil
}

// TotalDays returns the value of the "total_days" field in the mutation.
func (m *LeaveAllowanceMutation) TotalDays() (r float64, exists bool) {
	v := m.total_days
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalDays returns the old "total_days" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldTotalDays(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalDays: %w", err)
	}
	return oldValue.TotalDays, nil
}

// AddTotalDays adds f to the "total_days" field.
func (m *LeaveAllowanceMutation) AddTotalDays(f float64) {
	if m.addtotal_days != nil {
		*m.addtotal_days += f
	} else {
		m.addtotal_days = &f
	}
}

// AddedTotalDays returns the value that was added to the "total_days" field in this mutation.
func (m *LeaveAllowanceMutation) AddedTotalDays() (r float64, exists bool) {
	v := m.addtotal_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalDays resets all changes to the "total_days" field.
func (m *LeaveAllowanceMutation) ResetTotalDays() {
	m.total_days = nil
	m.addtotal_days = nil
}

// SetUsedDays sets the "used_days" field.
func (m *LeaveAllowanceMutation) SetUsedDays(f float64) {
	m.used_days = &f
	m.addused_days = nil
}

// UsedDays returns the value of the "used_days" field in the mutation.
func (m *LeaveAllowanceMutation) UsedDays() (r float64, exists bool) {
	v := m.used_days
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedDays returns the old "used_days" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldUsedDays(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedDays: %w", err)
	}
	return oldValue.UsedDays, nil
}

// AddUsedDays adds f to the "used_days" field.
func (m *LeaveAllowanceMutation) AddUsedDays(f float64) {
	if m.addused_days != nil {
		*m.addused_days += f
	} else {
		m.addused_days = &f
	}
}

// AddedUsedDays returns the value that was added to the "used_days" field in this mutation.
func (m *LeaveAllowanceMutation) AddedUsedDays() (r float64, exists bool) {
	v := m.addused_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedDays resets all changes to the "used_days" field.
func (m *LeaveAllowanceMutation) ResetUsedDays() {
	m.used_days = nil
	m.addused_days = nil
}

// SetCarriedOver sets the "carried_over" field.
func (m *LeaveAllowanceMutation) SetCarriedOver(f float64) {
	m.carried_over = &f
	m.addcarried_over = nil
}

// CarriedOver returns the value of the "carried_over" field in the mutation.
func (m *LeaveAllowanceMutation) CarriedOver() (r float64, exists bool) {
	v := m.carried_over
	if v == nil {
		return
	}
	return *v, true
}

// OldCarriedOver returns the old "carried_over" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldCarriedOver(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarriedOver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarriedOver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarriedOver: %w", err)
	}
	return oldValue.CarriedOver, nil
}

// AddCarriedOver adds f to the "carried_over" field.
func (m *LeaveAllowanceMutation) AddCarriedOver(f float64) {
	if m.addcarried_over != nil {
		*m.addcarried_over += f
	} else {
		m.addcarried_over = &f
	}
}

// AddedCarriedOver returns the value that was added to the "carried_over" field in this mutation.
func (m *LeaveAllowanceMutation) AddedCarriedOver() (r float64, exists bool) {
	v := m.addcarried_over
	if v == nil {
		return
	}
	return *v, true
}

// ResetCarriedOver resets all changes to the "carried_over" field.
func (m *LeaveAllowanceMutation) ResetCarriedOver() {
	m.carried_over = nil
	m.addcarried_over = nil
}

// SetNotes sets the "notes" field.
func (m *LeaveAllowanceMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *LeaveAllowanceMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the LeaveAllowance entity.
// If the LeaveAllowance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveAllowanceMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *LeaveAllowanceMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[leaveallowance.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *LeaveAllowanceMutation) NotesCleared() bool {
	_, ok := m.clearedFields[leaveallowance.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *LeaveAllowanceMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, leaveallowance.FieldNotes)
}

// ClearAbsenceType clears the "absence_type" edge to the AbsenceType entity.
func (m *LeaveAllowanceMutation) ClearAbsenceType() {
	m.clearedabsence_type = true
	m.clearedFields[leaveallowance.FieldAbsenceTypeID] = struct{}{}
}

// AbsenceTypeCleared reports if the "absence_type" edge to the AbsenceType entity was cleared.
func (m *LeaveAllowanceMutation) AbsenceTypeCleared() bool {
	return m.clearedabsence_type
}

// AbsenceTypeIDs returns the "absence_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbsenceTypeID instead. It exists only for internal usage by the builders.
func (m *LeaveAllowanceMutation) AbsenceTypeIDs() (ids []string) {
	if id := m.absence_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbsenceType resets all changes to the "absence_type" edge.
func (m *LeaveAllowanceMutation) ResetAbsenceType() {
	m.absence_type = nil
	m.clearedabsence_type = false
}

// Where appends a list predicates to the LeaveAllowanceMutation builder.
func (m *LeaveAllowanceMutation) Where(ps ...predicate.LeaveAllowance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeaveAllowanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeaveAllowanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeaveAllowance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeaveAllowanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeaveAllowanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeaveAllowance).
func (m *LeaveAllowanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeaveAllowanceMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_by != nil {
		fields = append(fields, leaveallowance.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, leaveallowance.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, leaveallowance.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, leaveallowance.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, leaveallowance.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, leaveallowance.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, leaveallowance.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, leaveallowance.FieldUserName)
	}
	if m.absence_type != nil {
		fields = append(fields, leaveallowance.FieldAbsenceTypeID)
	}
	if m.year != nil {
		fields = append(fields, leaveallowance.FieldYear)
	}
	if m.total_days != nil {
		fields = append(fields, leaveallowance.FieldTotalDays)
	}
	if m.used_days != nil {
		fields = append(fields, leaveallowance.FieldUsedDays)
	}
	if m.carried_over != nil {
		fields = append(fields, leaveallowance.FieldCarriedOver)
	}
	if m.notes != nil {
		fields = append(fields, leaveallowance.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeaveAllowanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leaveallowance.FieldCreateBy:
		return m.CreateBy()
	case leaveallowance.FieldUpdateBy:
		return m.UpdateBy()
	case leaveallowance.FieldCreateTime:
		return m.CreateTime()
	case leaveallowance.FieldUpdateTime:
		return m.UpdateTime()
	case leaveallowance.FieldDeleteTime:
		return m.DeleteTime()
	case leaveallowance.FieldTenantID:
		return m.TenantID()
	case leaveallowance.FieldUserID:
		return m.UserID()
	case leaveallowance.FieldUserName:
		return m.UserName()
	case leaveallowance.FieldAbsenceTypeID:
		return m.AbsenceTypeID()
	case leaveallowance.FieldYear:
		return m.Year()
	case leaveallowance.FieldTotalDays:
		return m.TotalDays()
	case leaveallowance.FieldUsedDays:
		return m.UsedDays()
	case leaveallowance.FieldCarriedOver:
		return m.CarriedOver()
	case leaveallowance.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeaveAllowanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leaveallowance.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case leaveallowance.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case leaveallowance.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case leaveallowance.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case leaveallowance.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case leaveallowance.FieldTenantID:
		return m.OldTenantID(ctx)
	case leaveallowance.FieldUserID:
		return m.OldUserID(ctx)
	case leaveallowance.FieldUserName:
		return m.OldUserName(ctx)
	case leaveallowance.FieldAbsenceTypeID:
		return m.OldAbsenceTypeID(ctx)
	case leaveallowance.FieldYear:
		return m.OldYear(ctx)
	case leaveallowance.FieldTotalDays:
		return m.OldTotalDays(ctx)
	case leaveallowance.FieldUsedDays:
		return m.OldUsedDays(ctx)
	case leaveallowance.FieldCarriedOver:
		return m.OldCarriedOver(ctx)
	case leaveallowance.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown LeaveAllowance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaveAllowanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leaveallowance.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case leaveallowance.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case leaveallowance.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case leaveallowance.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case leaveallowance.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case leaveallowance.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case leaveallowance.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case leaveallowance.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case leaveallowance.FieldAbsenceTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsenceTypeID(v)
		return nil
	case leaveallowance.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case leaveallowance.FieldTotalDays:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalDays(v)
		return nil
	case leaveallowance.FieldUsedDays:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedDays(v)
		return nil
	case leaveallowance.FieldCarriedOver:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarriedOver(v)
		return nil
	case leaveallowance.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown LeaveAllowance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeaveAllowanceMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, leaveallowance.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, leaveallowance.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, leaveallowance.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, leaveallowance.FieldUserID)
	}
	if m.addyear != nil {
		fields = append(fields, leaveallowance.FieldYear)
	}
	if m.addtotal_days != nil {
		fields = append(fields, leaveallowance.FieldTotalDays)
	}
	if m.addused_days != nil {
		fields = append(fields, leaveallowance.FieldUsedDays)
	}
	if m.addcarried_over != nil {
		fields = append(fields, leaveallowance.FieldCarriedOver)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeaveAllowanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case leaveallowance.FieldCreateBy:
		return m.AddedCreateBy()
	case leaveallowance.FieldUpdateBy:
		return m.AddedUpdateBy()
	case leaveallowance.FieldTenantID:
		return m.AddedTenantID()
	case leaveallowance.FieldUserID:
		return m.AddedUserID()
	case leaveallowance.FieldYear:
		return m.AddedYear()
	case leaveallowance.FieldTotalDays:
		return m.AddedTotalDays()
	case leaveallowance.FieldUsedDays:
		return m.AddedUsedDays()
	case leaveallowance.FieldCarriedOver:
		return m.AddedCarriedOver()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaveAllowanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case leaveallowance.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case leaveallowance.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case leaveallowance.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case leaveallowance.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case leaveallowance.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case leaveallowance.FieldTotalDays:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalDays(v)
		return nil
	case leaveallowance.FieldUsedDays:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedDays(v)
		return nil
	case leaveallowance.FieldCarriedOver:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCarriedOver(v)
		return nil
	}
	return fmt.Errorf("unknown LeaveAllowance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeaveAllowanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(leaveallowance.FieldCreateBy) {
		fields = append(fields, leaveallowance.FieldCreateBy)
	}
	if m.FieldCleared(leaveallowance.FieldUpdateBy) {
		fields = append(fields, leaveallowance.FieldUpdateBy)
	}
	if m.FieldCleared(leaveallowance.FieldCreateTime) {
		fields = append(fields, leaveallowance.FieldCreateTime)
	}
	if m.FieldCleared(leaveallowance.FieldUpdateTime) {
		fields = append(fields, leaveallowance.FieldUpdateTime)
	}
	if m.FieldCleared(leaveallowance.FieldDeleteTime) {
		fields = append(fields, leaveallowance.FieldDeleteTime)
	}
	if m.FieldCleared(leaveallowance.FieldTenantID) {
		fields = append(fields, leaveallowance.FieldTenantID)
	}
	if m.FieldCleared(leaveallowance.FieldUserName) {
		fields = append(fields, leaveallowance.FieldUserName)
	}
	if m.FieldCleared(leaveallowance.FieldNotes) {
		fields = append(fields, leaveallowance.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeaveAllowanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaveAllowanceMutation) ClearField(name string) error {
	switch name {
	case leaveallowance.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case leaveallowance.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case leaveallowance.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case leaveallowance.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case leaveallowance.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case leaveallowance.FieldTenantID:
		m.ClearTenantID()
		return nil
	case leaveallowance.FieldUserName:
		m.ClearUserName()
		return nil
	case leaveallowance.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown LeaveAllowance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeaveAllowanceMutation) ResetField(name string) error {
	switch name {
	case leaveallowance.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case leaveallowance.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case leaveallowance.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case leaveallowance.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case leaveallowance.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case leaveallowance.FieldTenantID:
		m.ResetTenantID()
		return nil
	case leaveallowance.FieldUserID:
		m.ResetUserID()
		return nil
	case leaveallowance.FieldUserName:
		m.ResetUserName()
		return nil
	case leaveallowance.FieldAbsenceTypeID:
		m.ResetAbsenceTypeID()
		return nil
	case leaveallowance.FieldYear:
		m.ResetYear()
		return nil
	case leaveallowance.FieldTotalDays:
		m.ResetTotalDays()
		return nil
	case leaveallowance.FieldUsedDays:
		m.ResetUsedDays()
		return nil
	case leaveallowance.FieldCarriedOver:
		m.ResetCarriedOver()
		return nil
	case leaveallowance.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown LeaveAllowance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeaveAllowanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.absence_type != nil {
		edges = append(edges, leaveallowance.EdgeAbsenceType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeaveAllowanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case leaveallowance.EdgeAbsenceType:
		if id := m.absence_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeaveAllowanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeaveAllowanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeaveAllowanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedabsence_type {
		edges = append(edges, leaveallowance.EdgeAbsenceType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeaveAllowanceMutation) EdgeCleared(name string) bool {
	switch name {
	case leaveallowance.EdgeAbsenceType:
		return m.clearedabsence_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeaveAllowanceMutation) ClearEdge(name string) error {
	switch name {
	case leaveallowance.EdgeAbsenceType:
		m.ClearAbsenceType()
		return nil
	}
	return fmt.Errorf("unknown LeaveAllowance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeaveAllowanceMutation) ResetEdge(name string) error {
	switch name {
	case leaveallowance.EdgeAbsenceType:
		m.ResetAbsenceType()
		return nil
	}
	return fmt.Errorf("unknown LeaveAllowance edge %s", name)
}

// LeaveRequestMutation represents an operation that mutates the LeaveRequest nodes in the graph.
type LeaveRequestMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	create_by           *uint32
	addcreate_by        *int32
	update_by           *uint32
	addupdate_by        *int32
	create_time         *time.Time
	update_time         *time.Time
	delete_time         *time.Time
	tenant_id           *uint32
	addtenant_id        *int32
	user_id             *uint32
	adduser_id          *int32
	user_name           *string
	org_unit_name       *string
	start_date          *time.Time
	end_date            *time.Time
	days                *float64
	adddays             *float64
	status              *leaverequest.Status
	reason              *string
	review_notes        *string
	reviewed_by         *uint32
	addreviewed_by      *int32
	reviewer_name       *string
	reviewed_at         *time.Time
	notes               *string
	metadata            *map[string]interface{}
	clearedFields       map[string]struct{}
	absence_type        *string
	clearedabsence_type bool
	done                bool
	oldValue            func(context.Context) (*LeaveRequest, error)
	predicates          []predicate.LeaveRequest
}

var _ ent.Mutation = (*LeaveRequestMutation)(nil)

// leaverequestOption allows management of the mutation configuration using functional options.
type leaverequestOption func(*LeaveRequestMutation)

// newLeaveRequestMutation creates new mutation for the LeaveRequest entity.
func newLeaveRequestMutation(c config, op Op, opts ...leaverequestOption) *LeaveRequestMutation {
	m := &LeaveRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeLeaveRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaveRequestID sets the ID field of the mutation.
func withLeaveRequestID(id string) leaverequestOption {
	return func(m *LeaveRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *LeaveRequest
		)
		m.oldValue = func(ctx context.Context) (*LeaveRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeaveRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeaveRequest sets the old LeaveRequest of the mutation.
func withLeaveRequest(node *LeaveRequest) leaverequestOption {
	return func(m *LeaveRequestMutation) {
		m.oldValue = func(context.Context) (*LeaveRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaveRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaveRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LeaveRequest entities.
func (m *LeaveRequestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeaveRequestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeaveRequestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeaveRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "create_by" field.
func (m *LeaveRequestMutation) SetCreateBy(u uint32) {
	m.create_by = &u
	m.addcreate_by = nil
}

// CreateBy returns the value of the "create_by" field in the mutation.
func (m *LeaveRequestMutation) CreateBy() (r uint32, exists bool) {
	v := m.create_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "create_by" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldCreateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// AddCreateBy adds u to the "create_by" field.
func (m *LeaveRequestMutation) AddCreateBy(u int32) {
	if m.addcreate_by != nil {
		*m.addcreate_by += u
	} else {
		m.addcreate_by = &u
	}
}

// AddedCreateBy returns the value that was added to the "create_by" field in this mutation.
func (m *LeaveRequestMutation) AddedCreateBy() (r int32, exists bool) {
	v := m.addcreate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateBy clears the value of the "create_by" field.
func (m *LeaveRequestMutation) ClearCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	m.clearedFields[leaverequest.FieldCreateBy] = struct{}{}
}

// CreateByCleared returns if the "create_by" field was cleared in this mutation.
func (m *LeaveRequestMutation) CreateByCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldCreateBy]
	return ok
}

// ResetCreateBy resets all changes to the "create_by" field.
func (m *LeaveRequestMutation) ResetCreateBy() {
	m.create_by = nil
	m.addcreate_by = nil
	delete(m.clearedFields, leaverequest.FieldCreateBy)
}

// SetUpdateBy sets the "update_by" field.
func (m *LeaveRequestMutation) SetUpdateBy(u uint32) {
	m.update_by = &u
	m.addupdate_by = nil
}

// UpdateBy returns the value of the "update_by" field in the mutation.
func (m *LeaveRequestMutation) UpdateBy() (r uint32, exists bool) {
	v := m.update_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "update_by" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldUpdateBy(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// AddUpdateBy adds u to the "update_by" field.
func (m *LeaveRequestMutation) AddUpdateBy(u int32) {
	if m.addupdate_by != nil {
		*m.addupdate_by += u
	} else {
		m.addupdate_by = &u
	}
}

// AddedUpdateBy returns the value that was added to the "update_by" field in this mutation.
func (m *LeaveRequestMutation) AddedUpdateBy() (r int32, exists bool) {
	v := m.addupdate_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdateBy clears the value of the "update_by" field.
func (m *LeaveRequestMutation) ClearUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	m.clearedFields[leaverequest.FieldUpdateBy] = struct{}{}
}

// UpdateByCleared returns if the "update_by" field was cleared in this mutation.
func (m *LeaveRequestMutation) UpdateByCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldUpdateBy]
	return ok
}

// ResetUpdateBy resets all changes to the "update_by" field.
func (m *LeaveRequestMutation) ResetUpdateBy() {
	m.update_by = nil
	m.addupdate_by = nil
	delete(m.clearedFields, leaverequest.FieldUpdateBy)
}

// SetCreateTime sets the "create_time" field.
func (m *LeaveRequestMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *LeaveRequestMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldCreateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *LeaveRequestMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[leaverequest.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *LeaveRequestMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *LeaveRequestMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, leaverequest.FieldCreateTime)
}

// SetUpdateTime sets the "update_time" field.
func (m *LeaveRequestMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *LeaveRequestMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldUpdateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ClearUpdateTime clears the value of the "update_time" field.
func (m *LeaveRequestMutation) ClearUpdateTime() {
	m.update_time = nil
	m.clearedFields[leaverequest.FieldUpdateTime] = struct{}{}
}

// UpdateTimeCleared returns if the "update_time" field was cleared in this mutation.
func (m *LeaveRequestMutation) UpdateTimeCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldUpdateTime]
	return ok
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *LeaveRequestMutation) ResetUpdateTime() {
	m.update_time = nil
	delete(m.clearedFields, leaverequest.FieldUpdateTime)
}

// SetDeleteTime sets the "delete_time" field.
func (m *LeaveRequestMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *LeaveRequestMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *LeaveRequestMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[leaverequest.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *LeaveRequestMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *LeaveRequestMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, leaverequest.FieldDeleteTime)
}

// SetTenantID sets the "tenant_id" field.
func (m *LeaveRequestMutation) SetTenantID(u uint32) {
	m.tenant_id = &u
	m.addtenant_id = nil
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LeaveRequestMutation) TenantID() (r uint32, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldTenantID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// AddTenantID adds u to the "tenant_id" field.
func (m *LeaveRequestMutation) AddTenantID(u int32) {
	if m.addtenant_id != nil {
		*m.addtenant_id += u
	} else {
		m.addtenant_id = &u
	}
}

// AddedTenantID returns the value that was added to the "tenant_id" field in this mutation.
func (m *LeaveRequestMutation) AddedTenantID() (r int32, exists bool) {
	v := m.addtenant_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *LeaveRequestMutation) ClearTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	m.clearedFields[leaverequest.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *LeaveRequestMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LeaveRequestMutation) ResetTenantID() {
	m.tenant_id = nil
	m.addtenant_id = nil
	delete(m.clearedFields, leaverequest.FieldTenantID)
}

// SetUserID sets the "user_id" field.
func (m *LeaveRequestMutation) SetUserID(u uint32) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LeaveRequestMutation) UserID() (r uint32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldUserID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *LeaveRequestMutation) AddUserID(u int32) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *LeaveRequestMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LeaveRequestMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetUserName sets the "user_name" field.
func (m *LeaveRequestMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the value of the "user_name" field in the mutation.
func (m *LeaveRequestMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "user_name" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "user_name" field.
func (m *LeaveRequestMutation) ClearUserName() {
	m.user_name = nil
	m.clearedFields[leaverequest.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "user_name" field was cleared in this mutation.
func (m *LeaveRequestMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "user_name" field.
func (m *LeaveRequestMutation) ResetUserName() {
	m.user_name = nil
	delete(m.clearedFields, leaverequest.FieldUserName)
}

// SetOrgUnitName sets the "org_unit_name" field.
func (m *LeaveRequestMutation) SetOrgUnitName(s string) {
	m.org_unit_name = &s
}

// OrgUnitName returns the value of the "org_unit_name" field in the mutation.
func (m *LeaveRequestMutation) OrgUnitName() (r string, exists bool) {
	v := m.org_unit_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgUnitName returns the old "org_unit_name" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldOrgUnitName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgUnitName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgUnitName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgUnitName: %w", err)
	}
	return oldValue.OrgUnitName, nil
}

// ClearOrgUnitName clears the value of the "org_unit_name" field.
func (m *LeaveRequestMutation) ClearOrgUnitName() {
	m.org_unit_name = nil
	m.clearedFields[leaverequest.FieldOrgUnitName] = struct{}{}
}

// OrgUnitNameCleared returns if the "org_unit_name" field was cleared in this mutation.
func (m *LeaveRequestMutation) OrgUnitNameCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldOrgUnitName]
	return ok
}

// ResetOrgUnitName resets all changes to the "org_unit_name" field.
func (m *LeaveRequestMutation) ResetOrgUnitName() {
	m.org_unit_name = nil
	delete(m.clearedFields, leaverequest.FieldOrgUnitName)
}

// SetAbsenceTypeID sets the "absence_type_id" field.
func (m *LeaveRequestMutation) SetAbsenceTypeID(s string) {
	m.absence_type = &s
}

// AbsenceTypeID returns the value of the "absence_type_id" field in the mutation.
func (m *LeaveRequestMutation) AbsenceTypeID() (r string, exists bool) {
	v := m.absence_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAbsenceTypeID returns the old "absence_type_id" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldAbsenceTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbsenceTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbsenceTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbsenceTypeID: %w", err)
	}
	return oldValue.AbsenceTypeID, nil
}

// ResetAbsenceTypeID resets all changes to the "absence_type_id" field.
func (m *LeaveRequestMutation) ResetAbsenceTypeID() {
	m.absence_type = nil
}

// SetStartDate sets the "start_date" field.
func (m *LeaveRequestMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *LeaveRequestMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *LeaveRequestMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *LeaveRequestMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *LeaveRequestMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *LeaveRequestMutation) ResetEndDate() {
	m.end_date = nil
}

// SetDays sets the "days" field.
func (m *LeaveRequestMutation) SetDays(f float64) {
	m.days = &f
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *LeaveRequestMutation) Days() (r float64, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldDays(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds f to the "days" field.
func (m *LeaveRequestMutation) AddDays(f float64) {
	if m.adddays != nil {
		*m.adddays += f
	} else {
		m.adddays = &f
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *LeaveRequestMutation) AddedDays() (r float64, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *LeaveRequestMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetStatus sets the "status" field.
func (m *LeaveRequestMutation) SetStatus(l leaverequest.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LeaveRequestMutation) Status() (r leaverequest.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldStatus(ctx context.Context) (v leaverequest.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LeaveRequestMutation) ResetStatus() {
	m.status = nil
}

// SetReason sets the "reason" field.
func (m *LeaveRequestMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *LeaveRequestMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *LeaveRequestMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[leaverequest.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *LeaveRequestMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *LeaveRequestMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, leaverequest.FieldReason)
}

// SetReviewNotes sets the "review_notes" field.
func (m *LeaveRequestMutation) SetReviewNotes(s string) {
	m.review_notes = &s
}

// ReviewNotes returns the value of the "review_notes" field in the mutation.
func (m *LeaveRequestMutation) ReviewNotes() (r string, exists bool) {
	v := m.review_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewNotes returns the old "review_notes" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldReviewNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewNotes: %w", err)
	}
	return oldValue.ReviewNotes, nil
}

// ClearReviewNotes clears the value of the "review_notes" field.
func (m *LeaveRequestMutation) ClearReviewNotes() {
	m.review_notes = nil
	m.clearedFields[leaverequest.FieldReviewNotes] = struct{}{}
}

// ReviewNotesCleared returns if the "review_notes" field was cleared in this mutation.
func (m *LeaveRequestMutation) ReviewNotesCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldReviewNotes]
	return ok
}

// ResetReviewNotes resets all changes to the "review_notes" field.
func (m *LeaveRequestMutation) ResetReviewNotes() {
	m.review_notes = nil
	delete(m.clearedFields, leaverequest.FieldReviewNotes)
}

// SetReviewedBy sets the "reviewed_by" field.
func (m *LeaveRequestMutation) SetReviewedBy(u uint32) {
	m.reviewed_by = &u
	m.addreviewed_by = nil
}

// ReviewedBy returns the value of the "reviewed_by" field in the mutation.
func (m *LeaveRequestMutation) ReviewedBy() (r uint32, exists bool) {
	v := m.reviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedBy returns the old "reviewed_by" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldReviewedBy(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedBy: %w", err)
	}
	return oldValue.ReviewedBy, nil
}

// AddReviewedBy adds u to the "reviewed_by" field.
func (m *LeaveRequestMutation) AddReviewedBy(u int32) {
	if m.addreviewed_by != nil {
		*m.addreviewed_by += u
	} else {
		m.addreviewed_by = &u
	}
}

// AddedReviewedBy returns the value that was added to the "reviewed_by" field in this mutation.
func (m *LeaveRequestMutation) AddedReviewedBy() (r int32, exists bool) {
	v := m.addreviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearReviewedBy clears the value of the "reviewed_by" field.
func (m *LeaveRequestMutation) ClearReviewedBy() {
	m.reviewed_by = nil
	m.addreviewed_by = nil
	m.clearedFields[leaverequest.FieldReviewedBy] = struct{}{}
}

// ReviewedByCleared returns if the "reviewed_by" field was cleared in this mutation.
func (m *LeaveRequestMutation) ReviewedByCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldReviewedBy]
	return ok
}

// ResetReviewedBy resets all changes to the "reviewed_by" field.
func (m *LeaveRequestMutation) ResetReviewedBy() {
	m.reviewed_by = nil
	m.addreviewed_by = nil
	delete(m.clearedFields, leaverequest.FieldReviewedBy)
}

// SetReviewerName sets the "reviewer_name" field.
func (m *LeaveRequestMutation) SetReviewerName(s string) {
	m.reviewer_name = &s
}

// ReviewerName returns the value of the "reviewer_name" field in the mutation.
func (m *LeaveRequestMutation) ReviewerName() (r string, exists bool) {
	v := m.reviewer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewerName returns the old "reviewer_name" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldReviewerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewerName: %w", err)
	}
	return oldValue.ReviewerName, nil
}

// ClearReviewerName clears the value of the "reviewer_name" field.
func (m *LeaveRequestMutation) ClearReviewerName() {
	m.reviewer_name = nil
	m.clearedFields[leaverequest.FieldReviewerName] = struct{}{}
}

// ReviewerNameCleared returns if the "reviewer_name" field was cleared in this mutation.
func (m *LeaveRequestMutation) ReviewerNameCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldReviewerName]
	return ok
}

// ResetReviewerName resets all changes to the "reviewer_name" field.
func (m *LeaveRequestMutation) ResetReviewerName() {
	m.reviewer_name = nil
	delete(m.clearedFields, leaverequest.FieldReviewerName)
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *LeaveRequestMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *LeaveRequestMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldReviewedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *LeaveRequestMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[leaverequest.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *LeaveRequestMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *LeaveRequestMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, leaverequest.FieldReviewedAt)
}

// SetNotes sets the "notes" field.
func (m *LeaveRequestMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *LeaveRequestMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *LeaveRequestMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[leaverequest.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *LeaveRequestMutation) NotesCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *LeaveRequestMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, leaverequest.FieldNotes)
}

// SetMetadata sets the "metadata" field.
func (m *LeaveRequestMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *LeaveRequestMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the LeaveRequest entity.
// If the LeaveRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaveRequestMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *LeaveRequestMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[leaverequest.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *LeaveRequestMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[leaverequest.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *LeaveRequestMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, leaverequest.FieldMetadata)
}

// ClearAbsenceType clears the "absence_type" edge to the AbsenceType entity.
func (m *LeaveRequestMutation) ClearAbsenceType() {
	m.clearedabsence_type = true
	m.clearedFields[leaverequest.FieldAbsenceTypeID] = struct{}{}
}

// AbsenceTypeCleared reports if the "absence_type" edge to the AbsenceType entity was cleared.
func (m *LeaveRequestMutation) AbsenceTypeCleared() bool {
	return m.clearedabsence_type
}

// AbsenceTypeIDs returns the "absence_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AbsenceTypeID instead. It exists only for internal usage by the builders.
func (m *LeaveRequestMutation) AbsenceTypeIDs() (ids []string) {
	if id := m.absence_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAbsenceType resets all changes to the "absence_type" edge.
func (m *LeaveRequestMutation) ResetAbsenceType() {
	m.absence_type = nil
	m.clearedabsence_type = false
}

// Where appends a list predicates to the LeaveRequestMutation builder.
func (m *LeaveRequestMutation) Where(ps ...predicate.LeaveRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeaveRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeaveRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeaveRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeaveRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeaveRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeaveRequest).
func (m *LeaveRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeaveRequestMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.create_by != nil {
		fields = append(fields, leaverequest.FieldCreateBy)
	}
	if m.update_by != nil {
		fields = append(fields, leaverequest.FieldUpdateBy)
	}
	if m.create_time != nil {
		fields = append(fields, leaverequest.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, leaverequest.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, leaverequest.FieldDeleteTime)
	}
	if m.tenant_id != nil {
		fields = append(fields, leaverequest.FieldTenantID)
	}
	if m.user_id != nil {
		fields = append(fields, leaverequest.FieldUserID)
	}
	if m.user_name != nil {
		fields = append(fields, leaverequest.FieldUserName)
	}
	if m.org_unit_name != nil {
		fields = append(fields, leaverequest.FieldOrgUnitName)
	}
	if m.absence_type != nil {
		fields = append(fields, leaverequest.FieldAbsenceTypeID)
	}
	if m.start_date != nil {
		fields = append(fields, leaverequest.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, leaverequest.FieldEndDate)
	}
	if m.days != nil {
		fields = append(fields, leaverequest.FieldDays)
	}
	if m.status != nil {
		fields = append(fields, leaverequest.FieldStatus)
	}
	if m.reason != nil {
		fields = append(fields, leaverequest.FieldReason)
	}
	if m.review_notes != nil {
		fields = append(fields, leaverequest.FieldReviewNotes)
	}
	if m.reviewed_by != nil {
		fields = append(fields, leaverequest.FieldReviewedBy)
	}
	if m.reviewer_name != nil {
		fields = append(fields, leaverequest.FieldReviewerName)
	}
	if m.reviewed_at != nil {
		fields = append(fields, leaverequest.FieldReviewedAt)
	}
	if m.notes != nil {
		fields = append(fields, leaverequest.FieldNotes)
	}
	if m.metadata != nil {
		fields = append(fields, leaverequest.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeaveRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leaverequest.FieldCreateBy:
		return m.CreateBy()
	case leaverequest.FieldUpdateBy:
		return m.UpdateBy()
	case leaverequest.FieldCreateTime:
		return m.CreateTime()
	case leaverequest.FieldUpdateTime:
		return m.UpdateTime()
	case leaverequest.FieldDeleteTime:
		return m.DeleteTime()
	case leaverequest.FieldTenantID:
		return m.TenantID()
	case leaverequest.FieldUserID:
		return m.UserID()
	case leaverequest.FieldUserName:
		return m.UserName()
	case leaverequest.FieldOrgUnitName:
		return m.OrgUnitName()
	case leaverequest.FieldAbsenceTypeID:
		return m.AbsenceTypeID()
	case leaverequest.FieldStartDate:
		return m.StartDate()
	case leaverequest.FieldEndDate:
		return m.EndDate()
	case leaverequest.FieldDays:
		return m.Days()
	case leaverequest.FieldStatus:
		return m.Status()
	case leaverequest.FieldReason:
		return m.Reason()
	case leaverequest.FieldReviewNotes:
		return m.ReviewNotes()
	case leaverequest.FieldReviewedBy:
		return m.ReviewedBy()
	case leaverequest.FieldReviewerName:
		return m.ReviewerName()
	case leaverequest.FieldReviewedAt:
		return m.ReviewedAt()
	case leaverequest.FieldNotes:
		return m.Notes()
	case leaverequest.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeaveRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leaverequest.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case leaverequest.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case leaverequest.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case leaverequest.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case leaverequest.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case leaverequest.FieldTenantID:
		return m.OldTenantID(ctx)
	case leaverequest.FieldUserID:
		return m.OldUserID(ctx)
	case leaverequest.FieldUserName:
		return m.OldUserName(ctx)
	case leaverequest.FieldOrgUnitName:
		return m.OldOrgUnitName(ctx)
	case leaverequest.FieldAbsenceTypeID:
		return m.OldAbsenceTypeID(ctx)
	case leaverequest.FieldStartDate:
		return m.OldStartDate(ctx)
	case leaverequest.FieldEndDate:
		return m.OldEndDate(ctx)
	case leaverequest.FieldDays:
		return m.OldDays(ctx)
	case leaverequest.FieldStatus:
		return m.OldStatus(ctx)
	case leaverequest.FieldReason:
		return m.OldReason(ctx)
	case leaverequest.FieldReviewNotes:
		return m.OldReviewNotes(ctx)
	case leaverequest.FieldReviewedBy:
		return m.OldReviewedBy(ctx)
	case leaverequest.FieldReviewerName:
		return m.OldReviewerName(ctx)
	case leaverequest.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	case leaverequest.FieldNotes:
		return m.OldNotes(ctx)
	case leaverequest.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown LeaveRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaveRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leaverequest.FieldCreateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case leaverequest.FieldUpdateBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case leaverequest.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case leaverequest.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case leaverequest.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case leaverequest.FieldTenantID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case leaverequest.FieldUserID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case leaverequest.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case leaverequest.FieldOrgUnitName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgUnitName(v)
		return nil
	case leaverequest.FieldAbsenceTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbsenceTypeID(v)
		return nil
	case leaverequest.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case leaverequest.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case leaverequest.FieldDays:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case leaverequest.FieldStatus:
		v, ok := value.(leaverequest.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case leaverequest.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case leaverequest.FieldReviewNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewNotes(v)
		return nil
	case leaverequest.FieldReviewedBy:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedBy(v)
		return nil
	case leaverequest.FieldReviewerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewerName(v)
		return nil
	case leaverequest.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	case leaverequest.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case leaverequest.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown LeaveRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeaveRequestMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_by != nil {
		fields = append(fields, leaverequest.FieldCreateBy)
	}
	if m.addupdate_by != nil {
		fields = append(fields, leaverequest.FieldUpdateBy)
	}
	if m.addtenant_id != nil {
		fields = append(fields, leaverequest.FieldTenantID)
	}
	if m.adduser_id != nil {
		fields = append(fields, leaverequest.FieldUserID)
	}
	if m.adddays != nil {
		fields = append(fields, leaverequest.FieldDays)
	}
	if m.addreviewed_by != nil {
		fields = append(fields, leaverequest.FieldReviewedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeaveRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case leaverequest.FieldCreateBy:
		return m.AddedCreateBy()
	case leaverequest.FieldUpdateBy:
		return m.AddedUpdateBy()
	case leaverequest.FieldTenantID:
		return m.AddedTenantID()
	case leaverequest.FieldUserID:
		return m.AddedUserID()
	case leaverequest.FieldDays:
		return m.AddedDays()
	case leaverequest.FieldReviewedBy:
		return m.AddedReviewedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaveRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case leaverequest.FieldCreateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateBy(v)
		return nil
	case leaverequest.FieldUpdateBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateBy(v)
		return nil
	case leaverequest.FieldTenantID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTenantID(v)
		return nil
	case leaverequest.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case leaverequest.FieldDays:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case leaverequest.FieldReviewedBy:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewedBy(v)
		return nil
	}
	return fmt.Errorf("unknown LeaveRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeaveRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(leaverequest.FieldCreateBy) {
		fields = append(fields, leaverequest.FieldCreateBy)
	}
	if m.FieldCleared(leaverequest.FieldUpdateBy) {
		fields = append(fields, leaverequest.FieldUpdateBy)
	}
	if m.FieldCleared(leaverequest.FieldCreateTime) {
		fields = append(fields, leaverequest.FieldCreateTime)
	}
	if m.FieldCleared(leaverequest.FieldUpdateTime) {
		fields = append(fields, leaverequest.FieldUpdateTime)
	}
	if m.FieldCleared(leaverequest.FieldDeleteTime) {
		fields = append(fields, leaverequest.FieldDeleteTime)
	}
	if m.FieldCleared(leaverequest.FieldTenantID) {
		fields = append(fields, leaverequest.FieldTenantID)
	}
	if m.FieldCleared(leaverequest.FieldUserName) {
		fields = append(fields, leaverequest.FieldUserName)
	}
	if m.FieldCleared(leaverequest.FieldOrgUnitName) {
		fields = append(fields, leaverequest.FieldOrgUnitName)
	}
	if m.FieldCleared(leaverequest.FieldReason) {
		fields = append(fields, leaverequest.FieldReason)
	}
	if m.FieldCleared(leaverequest.FieldReviewNotes) {
		fields = append(fields, leaverequest.FieldReviewNotes)
	}
	if m.FieldCleared(leaverequest.FieldReviewedBy) {
		fields = append(fields, leaverequest.FieldReviewedBy)
	}
	if m.FieldCleared(leaverequest.FieldReviewerName) {
		fields = append(fields, leaverequest.FieldReviewerName)
	}
	if m.FieldCleared(leaverequest.FieldReviewedAt) {
		fields = append(fields, leaverequest.FieldReviewedAt)
	}
	if m.FieldCleared(leaverequest.FieldNotes) {
		fields = append(fields, leaverequest.FieldNotes)
	}
	if m.FieldCleared(leaverequest.FieldMetadata) {
		fields = append(fields, leaverequest.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeaveRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaveRequestMutation) ClearField(name string) error {
	switch name {
	case leaverequest.FieldCreateBy:
		m.ClearCreateBy()
		return nil
	case leaverequest.FieldUpdateBy:
		m.ClearUpdateBy()
		return nil
	case leaverequest.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case leaverequest.FieldUpdateTime:
		m.ClearUpdateTime()
		return nil
	case leaverequest.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case leaverequest.FieldTenantID:
		m.ClearTenantID()
		return nil
	case leaverequest.FieldUserName:
		m.ClearUserName()
		return nil
	case leaverequest.FieldOrgUnitName:
		m.ClearOrgUnitName()
		return nil
	case leaverequest.FieldReason:
		m.ClearReason()
		return nil
	case leaverequest.FieldReviewNotes:
		m.ClearReviewNotes()
		return nil
	case leaverequest.FieldReviewedBy:
		m.ClearReviewedBy()
		return nil
	case leaverequest.FieldReviewerName:
		m.ClearReviewerName()
		return nil
	case leaverequest.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	case leaverequest.FieldNotes:
		m.ClearNotes()
		return nil
	case leaverequest.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown LeaveRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeaveRequestMutation) ResetField(name string) error {
	switch name {
	case leaverequest.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case leaverequest.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case leaverequest.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case leaverequest.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case leaverequest.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case leaverequest.FieldTenantID:
		m.ResetTenantID()
		return nil
	case leaverequest.FieldUserID:
		m.ResetUserID()
		return nil
	case leaverequest.FieldUserName:
		m.ResetUserName()
		return nil
	case leaverequest.FieldOrgUnitName:
		m.ResetOrgUnitName()
		return nil
	case leaverequest.FieldAbsenceTypeID:
		m.ResetAbsenceTypeID()
		return nil
	case leaverequest.FieldStartDate:
		m.ResetStartDate()
		return nil
	case leaverequest.FieldEndDate:
		m.ResetEndDate()
		return nil
	case leaverequest.FieldDays:
		m.ResetDays()
		return nil
	case leaverequest.FieldStatus:
		m.ResetStatus()
		return nil
	case leaverequest.FieldReason:
		m.ResetReason()
		return nil
	case leaverequest.FieldReviewNotes:
		m.ResetReviewNotes()
		return nil
	case leaverequest.FieldReviewedBy:
		m.ResetReviewedBy()
		return nil
	case leaverequest.FieldReviewerName:
		m.ResetReviewerName()
		return nil
	case leaverequest.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	case leaverequest.FieldNotes:
		m.ResetNotes()
		return nil
	case leaverequest.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown LeaveRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeaveRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.absence_type != nil {
		edges = append(edges, leaverequest.EdgeAbsenceType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeaveRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case leaverequest.EdgeAbsenceType:
		if id := m.absence_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeaveRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeaveRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeaveRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedabsence_type {
		edges = append(edges, leaverequest.EdgeAbsenceType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeaveRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case leaverequest.EdgeAbsenceType:
		return m.clearedabsence_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeaveRequestMutation) ClearEdge(name string) error {
	switch name {
	case leaverequest.EdgeAbsenceType:
		m.ClearAbsenceType()
		return nil
	}
	return fmt.Errorf("unknown LeaveRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeaveRequestMutation) ResetEdge(name string) error {
	switch name {
	case leaverequest.EdgeAbsenceType:
		m.ResetAbsenceType()
		return nil
	}
	return fmt.Errorf("unknown LeaveRequest edge %s", name)
}
