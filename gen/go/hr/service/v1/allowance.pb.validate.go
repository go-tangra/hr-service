// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: hr/service/v1/allowance.proto

package hrpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LeaveAllowance with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LeaveAllowance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveAllowance with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LeaveAllowanceMultiError,
// or nil if none found.
func (m *LeaveAllowance) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveAllowance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.AbsenceTypeId != nil {
		// no validation rules for AbsenceTypeId
	}

	if m.Year != nil {
		// no validation rules for Year
	}

	if m.TotalDays != nil {
		// no validation rules for TotalDays
	}

	if m.UsedDays != nil {
		// no validation rules for UsedDays
	}

	if m.CarriedOver != nil {
		// no validation rules for CarriedOver
	}

	if m.Notes != nil {
		// no validation rules for Notes
	}

	if m.AbsenceTypeName != nil {
		// no validation rules for AbsenceTypeName
	}

	if m.UserName != nil {
		// no validation rules for UserName
	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveAllowanceValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveAllowanceValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveAllowanceValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveAllowanceValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveAllowanceValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveAllowanceValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedBy != nil {
		// no validation rules for CreatedBy
	}

	if m.UpdatedBy != nil {
		// no validation rules for UpdatedBy
	}

	if len(errors) > 0 {
		return LeaveAllowanceMultiError(errors)
	}

	return nil
}

// LeaveAllowanceMultiError is an error wrapping multiple validation errors
// returned by LeaveAllowance.ValidateAll() if the designated constraints
// aren't met.
type LeaveAllowanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveAllowanceMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveAllowanceMultiError) AllErrors() []error { return m }

// LeaveAllowanceValidationError is the validation error returned by
// LeaveAllowance.Validate if the designated constraints aren't met.
type LeaveAllowanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveAllowanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveAllowanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveAllowanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveAllowanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveAllowanceValidationError) ErrorName() string { return "LeaveAllowanceValidationError" }

// Error satisfies the builtin error interface
func (e LeaveAllowanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveAllowance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveAllowanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveAllowanceValidationError{}

// Validate checks the field values on CreateAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAllowanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAllowanceRequestMultiError, or nil if none found.
func (m *CreateAllowanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAllowanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.AbsenceTypeId != nil {
		// no validation rules for AbsenceTypeId
	}

	if m.Year != nil {
		// no validation rules for Year
	}

	if m.TotalDays != nil {
		// no validation rules for TotalDays
	}

	if m.CarriedOver != nil {
		// no validation rules for CarriedOver
	}

	if m.Notes != nil {
		// no validation rules for Notes
	}

	if m.UserName != nil {
		// no validation rules for UserName
	}

	if len(errors) > 0 {
		return CreateAllowanceRequestMultiError(errors)
	}

	return nil
}

// CreateAllowanceRequestMultiError is an error wrapping multiple validation
// errors returned by CreateAllowanceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateAllowanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAllowanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAllowanceRequestMultiError) AllErrors() []error { return m }

// CreateAllowanceRequestValidationError is the validation error returned by
// CreateAllowanceRequest.Validate if the designated constraints aren't met.
type CreateAllowanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAllowanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAllowanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAllowanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAllowanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAllowanceRequestValidationError) ErrorName() string {
	return "CreateAllowanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAllowanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAllowanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAllowanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAllowanceRequestValidationError{}

// Validate checks the field values on CreateAllowanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAllowanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAllowanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAllowanceResponseMultiError, or nil if none found.
func (m *CreateAllowanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAllowanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAllowance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAllowanceResponseValidationError{
					field:  "Allowance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAllowanceResponseValidationError{
					field:  "Allowance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAllowance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAllowanceResponseValidationError{
				field:  "Allowance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAllowanceResponseMultiError(errors)
	}

	return nil
}

// CreateAllowanceResponseMultiError is an error wrapping multiple validation
// errors returned by CreateAllowanceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateAllowanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAllowanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAllowanceResponseMultiError) AllErrors() []error { return m }

// CreateAllowanceResponseValidationError is the validation error returned by
// CreateAllowanceResponse.Validate if the designated constraints aren't met.
type CreateAllowanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAllowanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAllowanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAllowanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAllowanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAllowanceResponseValidationError) ErrorName() string {
	return "CreateAllowanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAllowanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAllowanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAllowanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAllowanceResponseValidationError{}

// Validate checks the field values on GetAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllowanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllowanceRequestMultiError, or nil if none found.
func (m *GetAllowanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllowanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetAllowanceRequestMultiError(errors)
	}

	return nil
}

// GetAllowanceRequestMultiError is an error wrapping multiple validation
// errors returned by GetAllowanceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAllowanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllowanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllowanceRequestMultiError) AllErrors() []error { return m }

// GetAllowanceRequestValidationError is the validation error returned by
// GetAllowanceRequest.Validate if the designated constraints aren't met.
type GetAllowanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllowanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllowanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllowanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllowanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllowanceRequestValidationError) ErrorName() string {
	return "GetAllowanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllowanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllowanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllowanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllowanceRequestValidationError{}

// Validate checks the field values on GetAllowanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAllowanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAllowanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAllowanceResponseMultiError, or nil if none found.
func (m *GetAllowanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAllowanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAllowance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAllowanceResponseValidationError{
					field:  "Allowance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAllowanceResponseValidationError{
					field:  "Allowance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAllowance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAllowanceResponseValidationError{
				field:  "Allowance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAllowanceResponseMultiError(errors)
	}

	return nil
}

// GetAllowanceResponseMultiError is an error wrapping multiple validation
// errors returned by GetAllowanceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAllowanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAllowanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAllowanceResponseMultiError) AllErrors() []error { return m }

// GetAllowanceResponseValidationError is the validation error returned by
// GetAllowanceResponse.Validate if the designated constraints aren't met.
type GetAllowanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAllowanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAllowanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAllowanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAllowanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAllowanceResponseValidationError) ErrorName() string {
	return "GetAllowanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAllowanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAllowanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAllowanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAllowanceResponseValidationError{}

// Validate checks the field values on ListAllowancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAllowancesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAllowancesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAllowancesRequestMultiError, or nil if none found.
func (m *ListAllowancesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAllowancesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.NoPaging != nil {
		// no validation rules for NoPaging
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.Year != nil {
		// no validation rules for Year
	}

	if m.AbsenceTypeId != nil {
		// no validation rules for AbsenceTypeId
	}

	if len(errors) > 0 {
		return ListAllowancesRequestMultiError(errors)
	}

	return nil
}

// ListAllowancesRequestMultiError is an error wrapping multiple validation
// errors returned by ListAllowancesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListAllowancesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAllowancesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAllowancesRequestMultiError) AllErrors() []error { return m }

// ListAllowancesRequestValidationError is the validation error returned by
// ListAllowancesRequest.Validate if the designated constraints aren't met.
type ListAllowancesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAllowancesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAllowancesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAllowancesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAllowancesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAllowancesRequestValidationError) ErrorName() string {
	return "ListAllowancesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAllowancesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAllowancesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAllowancesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAllowancesRequestValidationError{}

// Validate checks the field values on ListAllowancesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListAllowancesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAllowancesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListAllowancesResponseMultiError, or nil if none found.
func (m *ListAllowancesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAllowancesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAllowancesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAllowancesResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAllowancesResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListAllowancesResponseMultiError(errors)
	}

	return nil
}

// ListAllowancesResponseMultiError is an error wrapping multiple validation
// errors returned by ListAllowancesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListAllowancesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAllowancesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAllowancesResponseMultiError) AllErrors() []error { return m }

// ListAllowancesResponseValidationError is the validation error returned by
// ListAllowancesResponse.Validate if the designated constraints aren't met.
type ListAllowancesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAllowancesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAllowancesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAllowancesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAllowancesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAllowancesResponseValidationError) ErrorName() string {
	return "ListAllowancesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAllowancesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAllowancesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAllowancesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAllowancesResponseValidationError{}

// Validate checks the field values on UpdateAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAllowanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateAllowanceRequestMultiError, or nil if none found.
func (m *UpdateAllowanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAllowanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAllowanceRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAllowanceRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAllowanceRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateAllowanceRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateAllowanceRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateAllowanceRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateAllowanceRequestMultiError(errors)
	}

	return nil
}

// UpdateAllowanceRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateAllowanceRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateAllowanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAllowanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAllowanceRequestMultiError) AllErrors() []error { return m }

// UpdateAllowanceRequestValidationError is the validation error returned by
// UpdateAllowanceRequest.Validate if the designated constraints aren't met.
type UpdateAllowanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAllowanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAllowanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAllowanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAllowanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAllowanceRequestValidationError) ErrorName() string {
	return "UpdateAllowanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAllowanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAllowanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAllowanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAllowanceRequestValidationError{}

// Validate checks the field values on UpdateAllowanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateAllowanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateAllowanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateAllowanceResponseMultiError, or nil if none found.
func (m *UpdateAllowanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateAllowanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAllowance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateAllowanceResponseValidationError{
					field:  "Allowance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateAllowanceResponseValidationError{
					field:  "Allowance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAllowance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateAllowanceResponseValidationError{
				field:  "Allowance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateAllowanceResponseMultiError(errors)
	}

	return nil
}

// UpdateAllowanceResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateAllowanceResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateAllowanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAllowanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAllowanceResponseMultiError) AllErrors() []error { return m }

// UpdateAllowanceResponseValidationError is the validation error returned by
// UpdateAllowanceResponse.Validate if the designated constraints aren't met.
type UpdateAllowanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAllowanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAllowanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAllowanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAllowanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAllowanceResponseValidationError) ErrorName() string {
	return "UpdateAllowanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAllowanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAllowanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAllowanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAllowanceResponseValidationError{}

// Validate checks the field values on DeleteAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAllowanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAllowanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAllowanceRequestMultiError, or nil if none found.
func (m *DeleteAllowanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAllowanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteAllowanceRequestMultiError(errors)
	}

	return nil
}

// DeleteAllowanceRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteAllowanceRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteAllowanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAllowanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAllowanceRequestMultiError) AllErrors() []error { return m }

// DeleteAllowanceRequestValidationError is the validation error returned by
// DeleteAllowanceRequest.Validate if the designated constraints aren't met.
type DeleteAllowanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAllowanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAllowanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAllowanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAllowanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAllowanceRequestValidationError) ErrorName() string {
	return "DeleteAllowanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAllowanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAllowanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAllowanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAllowanceRequestValidationError{}

// Validate checks the field values on BalanceEntry with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BalanceEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceEntry with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BalanceEntryMultiError, or
// nil if none found.
func (m *BalanceEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AbsenceTypeId

	// no validation rules for AbsenceTypeName

	// no validation rules for Color

	// no validation rules for TotalDays

	// no validation rules for UsedDays

	// no validation rules for CarriedOver

	// no validation rules for RemainingDays

	if len(errors) > 0 {
		return BalanceEntryMultiError(errors)
	}

	return nil
}

// BalanceEntryMultiError is an error wrapping multiple validation errors
// returned by BalanceEntry.ValidateAll() if the designated constraints aren't met.
type BalanceEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceEntryMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceEntryMultiError) AllErrors() []error { return m }

// BalanceEntryValidationError is the validation error returned by
// BalanceEntry.Validate if the designated constraints aren't met.
type BalanceEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceEntryValidationError) ErrorName() string { return "BalanceEntryValidationError" }

// Error satisfies the builtin error interface
func (e BalanceEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceEntryValidationError{}

// Validate checks the field values on GetUserBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserBalanceRequestMultiError, or nil if none found.
func (m *GetUserBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if m.Year != nil {
		// no validation rules for Year
	}

	if len(errors) > 0 {
		return GetUserBalanceRequestMultiError(errors)
	}

	return nil
}

// GetUserBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by GetUserBalanceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetUserBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserBalanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserBalanceRequestMultiError) AllErrors() []error { return m }

// GetUserBalanceRequestValidationError is the validation error returned by
// GetUserBalanceRequest.Validate if the designated constraints aren't met.
type GetUserBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserBalanceRequestValidationError) ErrorName() string {
	return "GetUserBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserBalanceRequestValidationError{}

// Validate checks the field values on GetUserBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetUserBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetUserBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetUserBalanceResponseMultiError, or nil if none found.
func (m *GetUserBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetUserBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for Year

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetUserBalanceResponseValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetUserBalanceResponseValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetUserBalanceResponseValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetUserBalanceResponseMultiError(errors)
	}

	return nil
}

// GetUserBalanceResponseMultiError is an error wrapping multiple validation
// errors returned by GetUserBalanceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetUserBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetUserBalanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetUserBalanceResponseMultiError) AllErrors() []error { return m }

// GetUserBalanceResponseValidationError is the validation error returned by
// GetUserBalanceResponse.Validate if the designated constraints aren't met.
type GetUserBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserBalanceResponseValidationError) ErrorName() string {
	return "GetUserBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserBalanceResponseValidationError{}
