// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: hr/service/v1/leave.proto

package hrpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on LeaveRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LeaveRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeaveRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LeaveRequestMultiError, or
// nil if none found.
func (m *LeaveRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LeaveRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeaveRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeaveRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeaveRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Id != nil {
		// no validation rules for Id
	}

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.AbsenceTypeId != nil {
		// no validation rules for AbsenceTypeId
	}

	if m.StartDate != nil {

		if all {
			switch v := interface{}(m.GetStartDate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "StartDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "StartDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndDate != nil {

		if all {
			switch v := interface{}(m.GetEndDate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "EndDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "EndDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Days != nil {
		// no validation rules for Days
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.Reason != nil {
		// no validation rules for Reason
	}

	if m.ReviewNotes != nil {
		// no validation rules for ReviewNotes
	}

	if m.ReviewedBy != nil {
		// no validation rules for ReviewedBy
	}

	if m.ReviewedAt != nil {

		if all {
			switch v := interface{}(m.GetReviewedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "ReviewedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "ReviewedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReviewedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveRequestValidationError{
					field:  "ReviewedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Notes != nil {
		// no validation rules for Notes
	}

	if m.UserName != nil {
		// no validation rules for UserName
	}

	if m.AbsenceTypeName != nil {
		// no validation rules for AbsenceTypeName
	}

	if m.AbsenceTypeColor != nil {
		// no validation rules for AbsenceTypeColor
	}

	if m.ReviewerName != nil {
		// no validation rules for ReviewerName
	}

	if m.OrgUnitName != nil {
		// no validation rules for OrgUnitName
	}

	if m.SigningRequestId != nil {
		// no validation rules for SigningRequestId
	}

	if m.CreatedAt != nil {

		if all {
			switch v := interface{}(m.GetCreatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "CreatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveRequestValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeaveRequestValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeaveRequestValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.CreatedBy != nil {
		// no validation rules for CreatedBy
	}

	if m.UpdatedBy != nil {
		// no validation rules for UpdatedBy
	}

	if len(errors) > 0 {
		return LeaveRequestMultiError(errors)
	}

	return nil
}

// LeaveRequestMultiError is an error wrapping multiple validation errors
// returned by LeaveRequest.ValidateAll() if the designated constraints aren't met.
type LeaveRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeaveRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeaveRequestMultiError) AllErrors() []error { return m }

// LeaveRequestValidationError is the validation error returned by
// LeaveRequest.Validate if the designated constraints aren't met.
type LeaveRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeaveRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeaveRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeaveRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeaveRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeaveRequestValidationError) ErrorName() string { return "LeaveRequestValidationError" }

// Error satisfies the builtin error interface
func (e LeaveRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeaveRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeaveRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeaveRequestValidationError{}

// Validate checks the field values on CreateLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLeaveRequestRequestMultiError, or nil if none found.
func (m *CreateLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLeaveRequestRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLeaveRequestRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLeaveRequestRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.AbsenceTypeId != nil {
		// no validation rules for AbsenceTypeId
	}

	if m.StartDate != nil {

		if all {
			switch v := interface{}(m.GetStartDate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateLeaveRequestRequestValidationError{
						field:  "StartDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateLeaveRequestRequestValidationError{
						field:  "StartDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateLeaveRequestRequestValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.EndDate != nil {

		if all {
			switch v := interface{}(m.GetEndDate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateLeaveRequestRequestValidationError{
						field:  "EndDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateLeaveRequestRequestValidationError{
						field:  "EndDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateLeaveRequestRequestValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Days != nil {
		// no validation rules for Days
	}

	if m.Reason != nil {
		// no validation rules for Reason
	}

	if m.Notes != nil {
		// no validation rules for Notes
	}

	if m.UserName != nil {
		// no validation rules for UserName
	}

	if m.OrgUnitName != nil {
		// no validation rules for OrgUnitName
	}

	if len(errors) > 0 {
		return CreateLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// CreateLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by CreateLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeaveRequestRequestMultiError) AllErrors() []error { return m }

// CreateLeaveRequestRequestValidationError is the validation error returned by
// CreateLeaveRequestRequest.Validate if the designated constraints aren't met.
type CreateLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeaveRequestRequestValidationError) ErrorName() string {
	return "CreateLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeaveRequestRequestValidationError{}

// Validate checks the field values on CreateLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLeaveRequestResponseMultiError, or nil if none found.
func (m *CreateLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaveRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaveRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLeaveRequestResponseValidationError{
				field:  "LeaveRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// CreateLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by CreateLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeaveRequestResponseMultiError) AllErrors() []error { return m }

// CreateLeaveRequestResponseValidationError is the validation error returned
// by CreateLeaveRequestResponse.Validate if the designated constraints aren't met.
type CreateLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeaveRequestResponseValidationError) ErrorName() string {
	return "CreateLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeaveRequestResponseValidationError{}

// Validate checks the field values on GetLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLeaveRequestRequestMultiError, or nil if none found.
func (m *GetLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// GetLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by GetLeaveRequestRequest.ValidateAll() if the designated
// constraints aren't met.
type GetLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeaveRequestRequestMultiError) AllErrors() []error { return m }

// GetLeaveRequestRequestValidationError is the validation error returned by
// GetLeaveRequestRequest.Validate if the designated constraints aren't met.
type GetLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeaveRequestRequestValidationError) ErrorName() string {
	return "GetLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeaveRequestRequestValidationError{}

// Validate checks the field values on GetLeaveRequestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLeaveRequestResponseMultiError, or nil if none found.
func (m *GetLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaveRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaveRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLeaveRequestResponseValidationError{
				field:  "LeaveRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// GetLeaveRequestResponseMultiError is an error wrapping multiple validation
// errors returned by GetLeaveRequestResponse.ValidateAll() if the designated
// constraints aren't met.
type GetLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeaveRequestResponseMultiError) AllErrors() []error { return m }

// GetLeaveRequestResponseValidationError is the validation error returned by
// GetLeaveRequestResponse.Validate if the designated constraints aren't met.
type GetLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeaveRequestResponseValidationError) ErrorName() string {
	return "GetLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeaveRequestResponseValidationError{}

// Validate checks the field values on ListLeaveRequestsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeaveRequestsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeaveRequestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeaveRequestsRequestMultiError, or nil if none found.
func (m *ListLeaveRequestsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeaveRequestsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.Page != nil {
		// no validation rules for Page
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.NoPaging != nil {
		// no validation rules for NoPaging
	}

	if m.Query != nil {
		// no validation rules for Query
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if m.AbsenceTypeId != nil {
		// no validation rules for AbsenceTypeId
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.StartDate != nil {
		// no validation rules for StartDate
	}

	if m.EndDate != nil {
		// no validation rules for EndDate
	}

	if len(errors) > 0 {
		return ListLeaveRequestsRequestMultiError(errors)
	}

	return nil
}

// ListLeaveRequestsRequestMultiError is an error wrapping multiple validation
// errors returned by ListLeaveRequestsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListLeaveRequestsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeaveRequestsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeaveRequestsRequestMultiError) AllErrors() []error { return m }

// ListLeaveRequestsRequestValidationError is the validation error returned by
// ListLeaveRequestsRequest.Validate if the designated constraints aren't met.
type ListLeaveRequestsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeaveRequestsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeaveRequestsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeaveRequestsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeaveRequestsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeaveRequestsRequestValidationError) ErrorName() string {
	return "ListLeaveRequestsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeaveRequestsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeaveRequestsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeaveRequestsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeaveRequestsRequestValidationError{}

// Validate checks the field values on ListLeaveRequestsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeaveRequestsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeaveRequestsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeaveRequestsResponseMultiError, or nil if none found.
func (m *ListLeaveRequestsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeaveRequestsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListLeaveRequestsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListLeaveRequestsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListLeaveRequestsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Total != nil {
		// no validation rules for Total
	}

	if len(errors) > 0 {
		return ListLeaveRequestsResponseMultiError(errors)
	}

	return nil
}

// ListLeaveRequestsResponseMultiError is an error wrapping multiple validation
// errors returned by ListLeaveRequestsResponse.ValidateAll() if the
// designated constraints aren't met.
type ListLeaveRequestsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeaveRequestsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeaveRequestsResponseMultiError) AllErrors() []error { return m }

// ListLeaveRequestsResponseValidationError is the validation error returned by
// ListLeaveRequestsResponse.Validate if the designated constraints aren't met.
type ListLeaveRequestsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeaveRequestsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeaveRequestsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeaveRequestsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeaveRequestsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeaveRequestsResponseValidationError) ErrorName() string {
	return "ListLeaveRequestsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeaveRequestsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeaveRequestsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeaveRequestsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeaveRequestsResponseValidationError{}

// Validate checks the field values on UpdateLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLeaveRequestRequestMultiError, or nil if none found.
func (m *UpdateLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLeaveRequestRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLeaveRequestRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLeaveRequestRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Data != nil {

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateLeaveRequestRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateLeaveRequestRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateLeaveRequestRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// UpdateLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLeaveRequestRequestMultiError) AllErrors() []error { return m }

// UpdateLeaveRequestRequestValidationError is the validation error returned by
// UpdateLeaveRequestRequest.Validate if the designated constraints aren't met.
type UpdateLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLeaveRequestRequestValidationError) ErrorName() string {
	return "UpdateLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLeaveRequestRequestValidationError{}

// Validate checks the field values on UpdateLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLeaveRequestResponseMultiError, or nil if none found.
func (m *UpdateLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaveRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaveRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateLeaveRequestResponseValidationError{
				field:  "LeaveRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// UpdateLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type UpdateLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLeaveRequestResponseMultiError) AllErrors() []error { return m }

// UpdateLeaveRequestResponseValidationError is the validation error returned
// by UpdateLeaveRequestResponse.Validate if the designated constraints aren't met.
type UpdateLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLeaveRequestResponseValidationError) ErrorName() string {
	return "UpdateLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLeaveRequestResponseValidationError{}

// Validate checks the field values on DeleteLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteLeaveRequestRequestMultiError, or nil if none found.
func (m *DeleteLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeleteLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// DeleteLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLeaveRequestRequestMultiError) AllErrors() []error { return m }

// DeleteLeaveRequestRequestValidationError is the validation error returned by
// DeleteLeaveRequestRequest.Validate if the designated constraints aren't met.
type DeleteLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLeaveRequestRequestValidationError) ErrorName() string {
	return "DeleteLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLeaveRequestRequestValidationError{}

// Validate checks the field values on ApproveLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveLeaveRequestRequestMultiError, or nil if none found.
func (m *ApproveLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.ReviewNotes != nil {
		// no validation rules for ReviewNotes
	}

	if m.ApproverEmail != nil {
		// no validation rules for ApproverEmail
	}

	if m.ApproverName != nil {
		// no validation rules for ApproverName
	}

	if m.RequesterEmail != nil {
		// no validation rules for RequesterEmail
	}

	if len(errors) > 0 {
		return ApproveLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// ApproveLeaveRequestRequestMultiError is an error wrapping multiple
// validation errors returned by ApproveLeaveRequestRequest.ValidateAll() if
// the designated constraints aren't met.
type ApproveLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveLeaveRequestRequestMultiError) AllErrors() []error { return m }

// ApproveLeaveRequestRequestValidationError is the validation error returned
// by ApproveLeaveRequestRequest.Validate if the designated constraints aren't met.
type ApproveLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveLeaveRequestRequestValidationError) ErrorName() string {
	return "ApproveLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveLeaveRequestRequestValidationError{}

// Validate checks the field values on ApproveLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ApproveLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApproveLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ApproveLeaveRequestResponseMultiError, or nil if none found.
func (m *ApproveLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ApproveLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaveRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApproveLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApproveLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaveRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApproveLeaveRequestResponseValidationError{
				field:  "LeaveRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ApproveLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// ApproveLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by ApproveLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type ApproveLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveLeaveRequestResponseMultiError) AllErrors() []error { return m }

// ApproveLeaveRequestResponseValidationError is the validation error returned
// by ApproveLeaveRequestResponse.Validate if the designated constraints
// aren't met.
type ApproveLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveLeaveRequestResponseValidationError) ErrorName() string {
	return "ApproveLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveLeaveRequestResponseValidationError{}

// Validate checks the field values on RejectLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RejectLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RejectLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RejectLeaveRequestRequestMultiError, or nil if none found.
func (m *RejectLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RejectLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if m.ReviewNotes != nil {
		// no validation rules for ReviewNotes
	}

	if len(errors) > 0 {
		return RejectLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// RejectLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by RejectLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type RejectLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RejectLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RejectLeaveRequestRequestMultiError) AllErrors() []error { return m }

// RejectLeaveRequestRequestValidationError is the validation error returned by
// RejectLeaveRequestRequest.Validate if the designated constraints aren't met.
type RejectLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RejectLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RejectLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RejectLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RejectLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RejectLeaveRequestRequestValidationError) ErrorName() string {
	return "RejectLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RejectLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRejectLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RejectLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RejectLeaveRequestRequestValidationError{}

// Validate checks the field values on RejectLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RejectLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RejectLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RejectLeaveRequestResponseMultiError, or nil if none found.
func (m *RejectLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RejectLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaveRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RejectLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RejectLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaveRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RejectLeaveRequestResponseValidationError{
				field:  "LeaveRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RejectLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// RejectLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by RejectLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type RejectLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RejectLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RejectLeaveRequestResponseMultiError) AllErrors() []error { return m }

// RejectLeaveRequestResponseValidationError is the validation error returned
// by RejectLeaveRequestResponse.Validate if the designated constraints aren't met.
type RejectLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RejectLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RejectLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RejectLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RejectLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RejectLeaveRequestResponseValidationError) ErrorName() string {
	return "RejectLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RejectLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRejectLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RejectLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RejectLeaveRequestResponseValidationError{}

// Validate checks the field values on CancelLeaveRequestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelLeaveRequestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLeaveRequestRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelLeaveRequestRequestMultiError, or nil if none found.
func (m *CancelLeaveRequestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLeaveRequestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CancelLeaveRequestRequestMultiError(errors)
	}

	return nil
}

// CancelLeaveRequestRequestMultiError is an error wrapping multiple validation
// errors returned by CancelLeaveRequestRequest.ValidateAll() if the
// designated constraints aren't met.
type CancelLeaveRequestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLeaveRequestRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLeaveRequestRequestMultiError) AllErrors() []error { return m }

// CancelLeaveRequestRequestValidationError is the validation error returned by
// CancelLeaveRequestRequest.Validate if the designated constraints aren't met.
type CancelLeaveRequestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLeaveRequestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLeaveRequestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLeaveRequestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLeaveRequestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLeaveRequestRequestValidationError) ErrorName() string {
	return "CancelLeaveRequestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelLeaveRequestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLeaveRequestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLeaveRequestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLeaveRequestRequestValidationError{}

// Validate checks the field values on CancelLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelLeaveRequestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelLeaveRequestResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelLeaveRequestResponseMultiError, or nil if none found.
func (m *CancelLeaveRequestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelLeaveRequestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaveRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelLeaveRequestResponseValidationError{
					field:  "LeaveRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaveRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelLeaveRequestResponseValidationError{
				field:  "LeaveRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelLeaveRequestResponseMultiError(errors)
	}

	return nil
}

// CancelLeaveRequestResponseMultiError is an error wrapping multiple
// validation errors returned by CancelLeaveRequestResponse.ValidateAll() if
// the designated constraints aren't met.
type CancelLeaveRequestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelLeaveRequestResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelLeaveRequestResponseMultiError) AllErrors() []error { return m }

// CancelLeaveRequestResponseValidationError is the validation error returned
// by CancelLeaveRequestResponse.Validate if the designated constraints aren't met.
type CancelLeaveRequestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelLeaveRequestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelLeaveRequestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelLeaveRequestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelLeaveRequestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelLeaveRequestResponseValidationError) ErrorName() string {
	return "CancelLeaveRequestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelLeaveRequestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelLeaveRequestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelLeaveRequestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelLeaveRequestResponseValidationError{}

// Validate checks the field values on CalendarEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CalendarEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CalendarEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CalendarEventMultiError, or
// nil if none found.
func (m *CalendarEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *CalendarEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserName

	// no validation rules for AbsenceTypeId

	// no validation rules for AbsenceTypeName

	// no validation rules for Color

	if all {
		switch v := interface{}(m.GetStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CalendarEventValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CalendarEventValidationError{
					field:  "StartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CalendarEventValidationError{
				field:  "StartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CalendarEventValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CalendarEventValidationError{
					field:  "EndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CalendarEventValidationError{
				field:  "EndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Days

	// no validation rules for Status

	// no validation rules for OrgUnitName

	if len(errors) > 0 {
		return CalendarEventMultiError(errors)
	}

	return nil
}

// CalendarEventMultiError is an error wrapping multiple validation errors
// returned by CalendarEvent.ValidateAll() if the designated constraints
// aren't met.
type CalendarEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalendarEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalendarEventMultiError) AllErrors() []error { return m }

// CalendarEventValidationError is the validation error returned by
// CalendarEvent.Validate if the designated constraints aren't met.
type CalendarEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalendarEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalendarEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalendarEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalendarEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalendarEventValidationError) ErrorName() string { return "CalendarEventValidationError" }

// Error satisfies the builtin error interface
func (e CalendarEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalendarEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalendarEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalendarEventValidationError{}

// Validate checks the field values on GetCalendarEventsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCalendarEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCalendarEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCalendarEventsRequestMultiError, or nil if none found.
func (m *GetCalendarEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCalendarEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TenantId != nil {
		// no validation rules for TenantId
	}

	if m.StartDate != nil {
		// no validation rules for StartDate
	}

	if m.EndDate != nil {
		// no validation rules for EndDate
	}

	if m.OrgUnitName != nil {
		// no validation rules for OrgUnitName
	}

	if m.UserId != nil {
		// no validation rules for UserId
	}

	if len(errors) > 0 {
		return GetCalendarEventsRequestMultiError(errors)
	}

	return nil
}

// GetCalendarEventsRequestMultiError is an error wrapping multiple validation
// errors returned by GetCalendarEventsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCalendarEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCalendarEventsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCalendarEventsRequestMultiError) AllErrors() []error { return m }

// GetCalendarEventsRequestValidationError is the validation error returned by
// GetCalendarEventsRequest.Validate if the designated constraints aren't met.
type GetCalendarEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCalendarEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCalendarEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCalendarEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCalendarEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCalendarEventsRequestValidationError) ErrorName() string {
	return "GetCalendarEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCalendarEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCalendarEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCalendarEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCalendarEventsRequestValidationError{}

// Validate checks the field values on GetCalendarEventsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCalendarEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCalendarEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCalendarEventsResponseMultiError, or nil if none found.
func (m *GetCalendarEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCalendarEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCalendarEventsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCalendarEventsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCalendarEventsResponseValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCalendarEventsResponseMultiError(errors)
	}

	return nil
}

// GetCalendarEventsResponseMultiError is an error wrapping multiple validation
// errors returned by GetCalendarEventsResponse.ValidateAll() if the
// designated constraints aren't met.
type GetCalendarEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCalendarEventsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCalendarEventsResponseMultiError) AllErrors() []error { return m }

// GetCalendarEventsResponseValidationError is the validation error returned by
// GetCalendarEventsResponse.Validate if the designated constraints aren't met.
type GetCalendarEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCalendarEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCalendarEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCalendarEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCalendarEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCalendarEventsResponseValidationError) ErrorName() string {
	return "GetCalendarEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCalendarEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCalendarEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCalendarEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCalendarEventsResponseValidationError{}
